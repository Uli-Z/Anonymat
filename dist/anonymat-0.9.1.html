<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Anonymat</title>
    
    <!-- Configuration block (set language, etc.) -->
    <!-- CONFIG-START -->
    <script>
      window.AppConfig = {
        language: "de"
      };
    </script>
    <!-- CONFIG-END -->

    <script>
      // App version (will be replaced by build script)
      window.appVersion = "0.9.1";
    </script>
    
    <!-- Responsive meta tag for proper scaling on mobile devices -->
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <!-- Link to external stylesheet -->
    <style>
/* ------------------------------
   Reset & Base Styles
------------------------------ */
* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

body {
  font-family: sans-serif;
  background: #fff;
  color: #333;
  display: flex;
  flex-direction: column;
  height: 100vh;
  overflow: hidden;
}

/* ------------------------------
   Header
------------------------------ */
header {
  display: flex;
  flex-direction: row;
  flex-wrap: nowrap;
  align-items: center;
  padding: 10px;
  background: #f8f8f8;
  box-shadow: 0 1px 3px rgba(0,0,0,0.1);
  position: relative;
  z-index: 1000;
}

.hamburger {
  font-size: 24px;
  cursor: pointer;
  margin-right: 10px;
}

@media (min-width: 768px) {
  .hamburger {
    display: none;
  }
}

.header-title h1 {
  font-size: 20px;
  margin: 0;
}

.header-title {
  display: flex;
  align-items: center;
}

.header-title .subtitle {
  font-size: 12px;
  color: #666;
}

@media (max-width: 500px) {
  .header-title .subtitle {
    display: none;
  }
}

/* Header-Actions – push these to the right */
.header-actions {
  display: none;
  gap: 10px;
  margin-left: auto;
}

@media (min-width: 768px) {
  .header-actions {
    display: flex;
  }
}

.header-actions button {
  background: none;
  border: none;
  cursor: pointer;
  font-size: 24px;
  color: #007bff;
}

/* ------------------------------
   Side Menu (Off-canvas)
------------------------------ */
#sideMenu {
  display: none;
}

@media (max-width: 767px) {
  #sideMenu {
    display: block;
    position: fixed;
    top: 0;
    left: 0;
    width: 250px;
    height: 100%;
    background: #fff;
    box-shadow: 2px 0 5px rgba(0,0,0,0.3);
    transform: translateX(-100%);
    transition: transform 0.3s ease;
    z-index: 2000;
    padding: 20px;
  }
  #sideMenu.open {
    transform: translateX(0);
  }
  #sideMenu .close-menu {
    font-size: 24px;
    cursor: pointer;
    margin-bottom: 20px;
  }
  #sideMenu ul {
    list-style: none;
    padding: 0;
  }
  #sideMenu li {
    margin-bottom: 15px;
  }
  #sideMenu a {
    text-decoration: none;
    color: #007bff;
    font-size: 16px;
    display: flex;
    align-items: center;
    gap: 8px;
  }
}

/* ------------------------------
   Main & Container
------------------------------ */
main {
  flex: 1;
  overflow-y: auto;
  padding: 10px;
  display: flex;
  justify-content: center;
}

#container {
  width: 100%;
  max-width: 800px;
  position: relative;
  border: 1px solid #ccc;
  border-radius: 4px;
  overflow: hidden;
  padding-bottom: 70px; /* Platz für Action-Buttons */
}

/* ------------------------------
   Editor & Highlight
------------------------------ */
#highlight {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 60px;
  z-index: 1;
  padding: 10px;
  font-size: 16px;
  font-family: monospace;
  line-height: 1.5;
  white-space: pre-wrap;
  word-wrap: break-word;
  background-color: #e6ffe6;
  pointer-events: none;
  will-change: transform;
}

#highlight.highlight-detected {
  background-color: #ffe6e6;
}

#highlight.highlight-clean {
  background-color: #e6ffe6;
}

#highlight.busy {
  opacity: 0.5;
}

#editor {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 60px;
  z-index: 2;
  padding: 10px;
  font-size: 16px;
  font-family: monospace;
  line-height: 1.5;
  background: transparent;
  border: none;
  resize: none;
  color: transparent;
  caret-color: black;
}

/* --- Neue Styles für die internen Highlight-Spans --- */
#highlight span.detected {
  background-color: rgba(255, 0, 0, 0.2); /* Sensible Daten – hellrot */
}

#highlight span.anonymized {
  background-color: rgba(0, 0, 255, 0.2); /* Anonymisierte Tokens – hellblau */
}

#highlight span.whitelisted {
  background-color: rgba(0, 255, 0, 0.2); /* Whitelist-Einträge – hellgrün */
}

#highlight span.placeholder {
  color: #888;
  font-style: italic;
}

/* ------------------------------
   Action Buttons
------------------------------ */
#actionButtons {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  display: flex;
  justify-content: space-between;
  padding: 10px;
  z-index: 3;
  background: #ffffff;
}

#actionButtons .action-btn {
  width: 40%;
  font-size: 1em;
  padding: 10px;
  margin: 0;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 5px;
  transition: background-color 0.3s;
}

#actionButtons #anonymizeBtn {
  background-color: #d1e7dd;
  color: #000;
}

#actionButtons #anonymizeBtn:hover {
  background-color: #c3d8cc;
}

#actionButtons #deanonymizeBtn {
  background-color: #f8d7da;
  color: #000;
}

#actionButtons #deanonymizeBtn:hover {
  background-color: #f5c2c7;
}

@media (max-width: 600px) {
  #actionButtons .action-btn {
    width: 50%;
  }
}

/* ------------------------------
   Progress Bar
------------------------------ */
#progressBar {
  position: absolute;
  left: 0;
  right: 0;
  bottom: 60px;
  height: 30px;
  background-color: #ddd;
  display: none;
  opacity: 1;
  transition: opacity 1s ease;
  z-index: 1000;
  overflow: hidden;
}

#progressBar.active {
  display: block;
}

#progressBar.fade-out {
  opacity: 0;
}

#progressFill {
  height: 100%;
  width: 0;
  background-color: #bbb;
  transition: width 200ms ease;
}

#progressFill.complete {
  background-color: #8f8;
}

#progressText {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: #000;
  font-weight: bold;
  pointer-events: none;
}

/* ------------------------------
   Modals
------------------------------ */
.modal {
  display: none;
  position: fixed;
  z-index: 2100;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0,0,0,0.5);
  transition: opacity 0.3s ease;
}

.modal-content {
  background-color: #fff;
  margin: 10% auto;
  padding: 20px;
  border-radius: 8px;
  width: 90%;
  max-width: 400px;
  box-shadow: 0 4px 8px rgba(0,0,0,0.2);
  font-family: sans-serif;
}

.modal-content h3 {
  margin-bottom: 15px;
  font-size: 20px;
  text-align: center;
  color: #333;
}

.modal-content label {
  display: block;
  margin-top: 10px;
  font-size: 14px;
  color: #555;
}

.modal-content input[type="text"] {
  width: 100%;
  padding: 8px;
  font-size: 16px;
  margin-top: 5px;
  border: 1px solid #ccc;
  border-radius: 4px;
}

.modal-buttons {
  text-align: center;
  margin-top: 20px;
}

.modal-buttons button {
  padding: 4px 8px;
  font-size: 13px;
  border: 1px solid #ccc;
  border-radius: 4px;
  cursor: pointer;
  margin: 2px;
  transition: background 0.2s ease;
  display: inline-flex;
  align-items: center;
  background-color: #f0f0f0;
  color: #333;
}

.modal-buttons button:hover {
  background-color: #e0e0e0;
}

.modal-buttons button .modal-icon {
  margin-right: 4px;
  display: inline-block;
  width: 16px;
  height: 16px;
}

/* ------------------------------
   Icons
------------------------------ */
header svg,
.header-actions button svg,
#sideMenu svg,
.action-btn svg {
  width: 16px;
  height: 16px;
}

.header-logo {
  width: 40px;
  height: 40px;
  margin-right: 10px;
}

.header-logo svg {
  width: 100%;
  height: 100%;
}

/* ------------------------------
   Kontextmenü
------------------------------ */
.context-menu {
  position: absolute;
  display: none;
  flex-direction: column;
  background: #fff;
  border: 1px solid #ccc;
  border-radius: 4px;
  box-shadow: 0 2px 5px rgba(0,0,0,0.3);
  padding: 5px;
  z-index: 2200;
}

.context-menu button {
  background: none;
  border: none;
  padding: 5px 10px;
  cursor: pointer;
  font-size: 14px;
  color: #007bff;
  width: 100%;
  text-align: left;
  display: flex;
  align-items: center;
  gap: 5px;
}

.context-menu button:hover {
  background: #f0f0f0;
}

.context-menu .icon {
  width: 16px;
  height: 16px;
  display: inline-block;
  margin-right: 5px;
  vertical-align: middle;
}

/* ------------------------------
   Custom Placeholder Modal & Options
------------------------------ */
#customPlaceholderModal {
  display: none;
  position: fixed;
  z-index: 2200;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  background: rgba(0,0,0,0.5);
}

#customPlaceholderModal .modal-content {
  background: #fff;
  margin: 10% auto;
  padding: 20px;
  border-radius: 8px;
  width: 90%;
  max-width: 400px;
  box-shadow: 0 4px 8px rgba(0,0,0,0.2);
}

#placeholderOptionsContent {
  max-height: 80vh;
  overflow-y: auto;
  padding: 10px;
}

/* Placeholder Options Sections */
.placeholder-section {
  margin-bottom: 20px;
}

/* Styled Placeholder List */
.placeholder-list {
  border: 1px solid #ccc;
  padding: 10px;
  border-radius: 4px;
  max-height: 300px;
  overflow-y: auto;
  background-color: #f9f9f9;
}

/* Individual Placeholder Item */
.placeholder-item {
  display: flex;
  align-items: center;
  margin-bottom: 8px;
}

.placeholder-checkbox {
  margin-right: 8px;
}

.placeholder-label {
  font-weight: bold;
}

/* Toggle Button for Inactive Placeholders */
.toggle-button {
  margin-left: 10px;
  font-size: 0.9em;
  cursor: pointer;
}

/* Update Button */
.update-button {
  margin-top: 10px;
  padding: 8px 12px;
  background-color: #e0e0e0;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

/* Message when no active placeholders exist */
.no-active-placeholders {
  font-style: italic;
  color: #666;
}

/* ------------------------------
   Overlay Copy Button (unauffällig)
------------------------------ */
#copyOverlayBtn {
  position: absolute;
  top: 5px;
  right: 5px;
  z-index: 4;
  padding: 0;
  background: none;
  border: none;
  font-size: 12px;
  color: gray;
  cursor: pointer;
}

/* Styling for modal general layout (falls noch nicht vorhanden) */
.modal {
  display: none;
  position: fixed;
  z-index: 1000;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  overflow: auto; /* Enables scroll for small screens */
  background-color: rgba(0, 0, 0, 0.5);
  padding: 10px;
}

.modal-content {
  background-color: #fff;
  margin: 5% auto;
  padding: 20px 30px;
  border: 1px solid #888;
  border-radius: 8px;
  width: 80%;
  max-width: 600px;
  max-height: 80%;
  overflow-y: auto; /* scrollable on small screens */
  box-shadow: 0 5px 15px rgba(0,0,0,0.3);
}

/* Specific help modal styling */
#helpModal h3 {
  text-align: center;
  margin-bottom: 20px;
}

#helpModal p {
  margin-bottom: 1.2em;
  line-height: 1.6;
  font-size: 1rem;
  text-align: left;
}

#helpModal p:last-of-type {
  margin-bottom: 2em;
}

#helpModal button {
  padding: 10px 20px;
  font-size: 1rem;
  border-radius: 4px;
  border: none;
  background-color: #0077cc;
  color: white;
  cursor: pointer;
  transition: background-color 0.3s;
}

#helpModal button:hover {
  background-color: #005fa3;
}

/* First-Run Modal Styles */
#firstRunModal {
  display: none; /* Hidden by default, shown via JavaScript */
  position: fixed;
  z-index: 2100;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  overflow: auto;
  background-color: rgba(0, 0, 0, 0.5);
}

#firstRunModal .modal-content {
  max-width: 500px;
  margin: 100px auto;
  padding: 20px;
  border-radius: 8px;
  box-shadow: 0 4px 8px rgba(0,0,0,0.2);
  background-color: #fff;
  text-align: left;
}

#firstRunModal h3 {
  font-size: 1.5em;
  margin-bottom: 10px;
}

/* Warning emoji added via pseudo-element */
#firstRunModal h3::before {
  content: "⚠️";
  display: inline-block;
  margin-right: 8px;
  font-size: 1.2em;
  transform: translateY(-2px);
}

#firstRunModal p {
  line-height: 1.4;
  margin-bottom: 20px;
}

/* Checkbox styling - subtle and centered */
.first-run-checkbox {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 10px;
  margin-bottom: 20px;
}

.first-run-checkbox input[type="checkbox"] {
  width: 20px;
  height: 20px;
  accent-color: #0077cc;
}

.first-run-checkbox label {
  line-height: 20px; /* Matches checkbox height */
  display: inline-block;
  vertical-align: middle;
}

/* OK button styling - modern and prominent */
.first-run-button {
  text-align: center;
  margin-bottom: 20px;
}

.first-run-button button {
  width: 50%;
  padding: 10px 0;
  font-size: 16px;
  border: none;
  border-radius: 4px;
  background-color: #0077cc;
  color: #fff;
  cursor: pointer;
  transition: background-color 0.3s ease;
}

.first-run-button button:disabled {
  background-color: #ccc;
  cursor: not-allowed;
}

.first-run-button button:hover {
  background-color: #005fa3;
}

/* Language settings positioned lower and centered */
.language-settings {
  margin-top: 30px;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
}

</style>
    
    <!-- Include translations and configuration scripts -->
    <script>
(function (window) {
  window.translations = {
    de: {
      headerTitle: "Anonymat",
      headerSubtitle: "Persönliche Informationen lokal maskieren",
      addPlaceholder: "Platzhalter hinzufügen",
      settings: "Platzhaltereinstellungen",
      languageChange: "Sprache ändern",
      help: "Hilfe/About",
      mapping: "Mapping anzeigen",
      programSave: "Programm als separate Datei speichern",
      close: "Schließen",
      placeholderOptions: "Platzhaltereinstellungen",
      helpTitle: "Über Anonymat",
      helpDescription: "Anonymat ist ein Tool zur teilautomatisierten Maskierung und Anonymisierung personenbezogener Daten in Texten.",
      helpLocal: "Diese Anwendung läuft vollständig lokal im Browser und kommuniziert nicht mit externen Diensten.",
      helpDsGvo: "Das Tool unterstützt DSGVO-konforme Arbeitsabläufe. (Die DSGVO – Datenschutz-Grundverordnung – ist eine europäische Verordnung zum Schutz personenbezogener Daten.)",
      helpResponsibility: "Wichtig: Anonymat bietet eine Teilautomatisierung. Die Endverantwortung und Kontrolle liegen immer beim Anwender.",
      helpLicense: "Dieses Projekt ist Open Source und steht unter der GPL-3-Lizenz.",
      "helpVersion": "Version: {0} | © 2025 Uli-Z | GitHub: <a href='https://github.com/Uli-Z/Anonymat' target='_blank'>Anonymat</a>",
      anonymize: "Anonymisieren",
      deanonymize: "Deanonymisieren",
      editorPlaceholder: "Hier Text einfügen...",
      customPatternPlaceholder: "Hier zu ersetzenden Text eingeben",
      anonymizedStatus: "Text vollständig anonymisiert",
      deanonymizedStatus: "Text vollständig deanonymisiert",
      copyToClipboard: "In Zwischenablage kopieren",
      copySuccess: "Text in Zwischenablage kopiert",
      clipboardNotAvailable: "Zwischenablage nicht verfügbar.",
      "contextMenu.makeWholeTextAnonymizable": "Gesamten Text wieder anonymisierbar machen",
      "contextMenu.makeTextAnonymizable": "„{1}“ wieder anonymisierbar machen",
      "contextMenu.removePlaceholder": "Platzhalter-Typ {1} entfernen",
      "contextMenu.unmaskSelection": "Auswahl deanonymisieren",
      "contextMenu.neverAnonymize": "Diese Zeichenkette niemals maskieren",
      "contextMenu.addPlaceholder": "Platzhalter hinzufügen",
      "contextMenu.customPlaceholders": "Benutzerdefinierte Platzhalter",
      "contextMenu.activePlaceholders": "Aktive Platzhalter",
      "contextMenu.noActivePlaceholders": "Aktuell keine aktiven Platzhalter.",
      "contextMenu.additionalPlaceholders": "Weitere Platzhalter",
      "contextMenu.showAdditionalPlaceholders": "Anzeigen",
      "contextMenu.hideAdditionalPlaceholders": "Verbergen",
      "contextMenu.updateStatus": "Status aktualisieren",
      "contextMenu.statusUpdated": "Platzhalter-Status aktualisiert.",
      "contextMenu.anonymizeSelection": "Auswahl anonymisieren ({1})",
      // First-run modal translations
      "firstRunModal.title": "Wichtiger Hinweis:",
      "firstRunModal.text": "Dieses Programm übernimmt keine Garantie für die hundertprozentige Erkennung sensibler Informationen in Texten. Die Endverantwortung liegt beim Benutzer. Dieses Tool dient ausschließlich als semiautomatische Unterstützung zur Anonymisierung von Texten.",
      "firstRunModal.checkbox": "Ich habe das gelesen und verstanden",
      "firstRunModal.languageLabel": "Sprache:",
      "firstRunModal.okButton": "OK"
    },
    en: {
      headerTitle: "Anonymat",
      headerSubtitle: "Mask personal information locally",
      addPlaceholder: "Add placeholder",
      settings: "Placeholder settings",
      languageChange: "Change language",
      help: "Help/About",
      mapping: "Show mapping",
      programSave: "Save program as separate file",
      close: "Close",
      placeholderOptions: "Placeholder settings",
      helpTitle: "About Anonymat",
      helpDescription: "Anonymat is a tool for semi-automatic masking and anonymization of personal data in texts.",
      helpLocal: "This application runs entirely locally in your browser and does not communicate with external services.",
      helpDsGvo: "The tool is designed to support GDPR-compliant workflows. (The GDPR – General Data Protection Regulation – is a European regulation for data privacy and security.)",
      helpResponsibility: "Important: Anonymat offers partial automation. The final responsibility and verification always remain with the user.",
      helpLicense: "This project is open source and licensed under the GPL-3 license.",
      "helpVersion": "Version: {0} | © 2025 Uli-Z | GitHub: <a href='https://github.com/Uli-Z/Anonymat' target='_blank'>Anonymat</a>",
      anonymize: "Anonymize",
      deanonymize: "Deanonymize",
      editorPlaceholder: "Insert text here...",
      customPatternPlaceholder: "Enter text to be replaced",
      anonymizedStatus: "Text fully anonymized",
      deanonymizedStatus: "Text fully deanonymized",
      copyToClipboard: "Copy to Clipboard",
      copySuccess: "Text copied to Clipboard",
      clipboardNotAvailable: "Clipboard API not available.",
      "contextMenu.makeWholeTextAnonymizable": "Make entire text anonymizable",
      "contextMenu.makeTextAnonymizable": "Make \"{1}\" anonymizable",
      "contextMenu.removePlaceholder": "Remove placeholder type {1}",
      "contextMenu.unmaskSelection": "Deanonymize selection",
      "contextMenu.neverAnonymize": "Never anonymize this text",
      "contextMenu.addPlaceholder": "Add placeholder",
      "contextMenu.customPlaceholders": "Custom Placeholders",
      "contextMenu.activePlaceholders": "Active Placeholders",
      "contextMenu.noActivePlaceholders": "Currently no active placeholders.",
      "contextMenu.additionalPlaceholders": "Additional Placeholders",
      "contextMenu.showAdditionalPlaceholders": "Show",
      "contextMenu.hideAdditionalPlaceholders": "Hide",
      "contextMenu.updateStatus": "Update status",
      "contextMenu.statusUpdated": "Placeholder status updated.",
      "contextMenu.anonymizeSelection": "Anonymize selection ({1})",
      // First-run modal translations
      "firstRunModal.title": "Important Notice:",
      "firstRunModal.text": "This program does not guarantee 100% detection of sensitive information in texts. The ultimate responsibility lies with the user. This tool is intended solely as semi-automatic support for text anonymization.",
      "firstRunModal.checkbox": "I have read and understood",
      "firstRunModal.languageLabel": "Language:",
      "firstRunModal.okButton": "OK"
    }
  };

  if (typeof window.translate !== "function") {
    window.translate = function (key, params) {
      const lang = (window.Config && window.Config.get("language")) || "en";
      const trans = window.translations[lang] && window.translations[lang][key]
        ? window.translations[lang][key]
        : key;
      if (params && params.length > 0) {
        return trans.replace(/{(\d+)}/g, function (match, number) {
          return typeof params[number - 1] !== "undefined"
            ? params[number - 1]
            : match;
        });
      }
      return trans;
    };
  }
})(window);

</script>
    <script>
/**
 * config.js
 * Manages application configuration and cookie storage.
 */
(function (window) {
    // Set a cookie with a specified name, value, and expiration (in days)
    function setCookie(name, value, days) {
      var expires = "";
      if (days) {
        var date = new Date();
        date.setTime(date.getTime() + days * 24 * 60 * 60 * 1000);
        expires = "; expires=" + date.toUTCString();
      }
      document.cookie = name + "=" + (value || "") + expires + "; path=/";
    }
  
    // Retrieve a cookie value by name
    function getCookie(name) {
      var nameEQ = name + "=";
      var ca = document.cookie.split(";");
      for (var i = 0; i < ca.length; i++) {
        var c = ca[i].trim();
        if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length);
      }
      return null;
    }
  
    // Load configuration from a cookie, or return default config on error or if not found
    function loadConfig() {
      var cookieConfig = getCookie("AppConfig");
      if (cookieConfig) {
        try {
          return JSON.parse(cookieConfig);
        } catch (e) {
          console.error("Error parsing AppConfig cookie", e);
        }
      }
      return {
        language: "de"
      };
    }
  
    // Save the configuration object to a cookie
    function saveConfig(config) {
      setCookie("AppConfig", JSON.stringify(config), 30);
    }
  
    // Global configuration object with getter, setter, and updater methods
    window.Config = {
      config: loadConfig(),
  
      // Get a configuration value by key
      get: function (key) {
        return this.config[key];
      },
  
      // Set a configuration value and persist the change
      set: function (key, value) {
        this.config[key] = value;
        saveConfig(this.config);
      },
  
      // Update multiple configuration values and persist changes
      update: function (newConfig) {
        for (var key in newConfig) {
          if (newConfig.hasOwnProperty(key)) {
            this.config[key] = newConfig[key];
          }
        }
        saveConfig(this.config);
      }
    };
  
    // Expose cookie helper functions for debugging or advanced use
    window.Config._setCookie = setCookie;
    window.Config._getCookie = getCookie;
  })(window);
  
</script>
    
    <!-- Include additional libraries and modules -->
    <script>
"use strict";

(function (window) {
  /**
   * Icons used in the application as SVG strings.
   * All icons are attached to the global 'Icons' object.
   */
  window.Icons = {
      options: `<svg viewBox="0 0 30 30" version="1.1" xmlns="http://www.w3.org/2000/svg">
        <title>settings</title>
        <desc>Created with Sketch Beta.</desc>
        <defs></defs>
        <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
          <g transform="translate(-103,-362)" fill="#000000">
            <path d="M118,382 C115.261,382 113.042,379.762 113.042,377 C113.042,374.238 115.261,372 118,372 C120.739,372 122.959,374.238 122.959,377 C122.959,379.762 120.739,382 118,382 Z M132.008,380.536 L129.685,379.184 C129.815,378.474 129.901,377.749 129.901,377 C129.901,376.252 129.815,375.526 129.685,374.816 L132.008,373.464 C132.957,372.912 133.281,371.688 132.733,370.732 L130.75,367.268 C130.203,366.312 128.989,365.983 128.041,366.536 L125.694,367.901 C124.598,366.961 123.352,366.192 121.967,365.697 L121.967,364 C121.967,362.896 121.079,362 119.983,362 L116.017,362 C114.921,362 114.033,362.896 114.033,364 L114.033,365.697 C112.648,366.192 111.402,366.961 110.306,367.901 L107.959,366.536 C107.011,365.983 105.797,366.312 105.25,367.268 L103.267,370.732 C102.719,371.688 103.044,372.912 103.992,373.464 L106.315,374.816 C106.185,375.526 106.099,376.252 106.099,377 C106.099,377.749 106.185,378.474 106.315,379.184 L103.992,380.536 C103.044,381.088 102.719,382.312 103.267,383.268 L105.25,386.732 C105.797,387.688 107.011,388.017 107.959,387.464 L110.306,386.099 C111.402,387.039 112.648,387.809 114.033,388.303 L114.033,390 C114.033,391.104 114.921,392 116.017,392 L119.983,392 C121.079,392 121.967,391.104 121.967,390 L121.967,388.303 C123.352,387.809 124.598,387.039 125.694,386.099 L128.041,387.464 C128.989,388.017 130.203,387.688 130.75,386.732 L132.733,383.268 C133.281,382.312 132.957,381.088 132.008,380.536 Z M118,374 C116.357,374 115.025,375.344 115.025,377 C115.025,378.657 116.357,380 118,380 C119.643,380 120.975,378.657 120.975,377 C120.975,375.344 119.643,374 118,374 Z"></path>
          </g>
        </g>
      </svg>`,
        
      addPlaceholder: `<svg viewBox="0 0 32 32" version="1.1" xmlns="http://www.w3.org/2000/svg">
        <title>zoom-in</title>
        <desc>Created with Sketch Beta.</desc>
        <defs></defs>
        <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
          <g transform="translate(-310,-1141)" fill="#000000">
            <path d="M328.519,1155.41 L324.522,1155.41 L324.522,1159.41 C324.522,1159.97 324.075,1160.41 323.523,1160.41 C322.972,1160.41 322.524,1159.97 322.524,1159.41 L322.524,1155.41 L318.529,1155.41 C317.978,1155.41 317.53,1154.7 317.53,1154.14 C317.53,1153.59 317.978,1153.41 318.529,1153.41 L322.524,1153.41 L322.524,1149.41 C322.524,1148.85 322.972,1148.41 323.523,1148.41 C324.075,1148.41 324.522,1148.85 324.522,1149.41 L324.522,1153.41 L328.519,1153.41 C329.07,1153.41 329.518,1153.86 329.518,1154.41 C329.518,1154.96 329.07,1155.41 328.519,1155.41 L328.519,1155.41 Z M341.688,1171.25 L333.429,1163.12 C335.592,1160.77 336.92,1157.67 336.92,1154.25 C336.92,1146.93 330.894,1141 323.46,1141 C316.026,1141 310,1146.93 310,1154.25 C310,1161.56 316.026,1167.49 323.46,1167.49 C326.672,1167.49 329.618,1166.38 331.932,1164.53 L340.225,1172.69 C340.629,1173.09 341.284,1173.09 341.688,1171.25 C342.093,1172.3 342.093,1171.65 341.688,1171.25 Z"></path>
          </g>
        </g>
      </svg>`,
      
      deanonymize: `<svg viewBox="0 0 32 32" version="1.1" xmlns="http://www.w3.org/2000/svg">
        <title>refresh</title>
        <desc>Created with Sketch Beta.</desc>
        <defs></defs>
        <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
          <g transform="translate(-154,-1141)" fill="#000000">
            <path d="M184.858,1143.56 C185.397,1143.02 186.009,1142.55 186.009,1142 C186.009,1141.45 185.562,1141 185.009,1141 L175.009,1141 C174.888,1141 174.009,1141 174.009,1142 L174.009,1152 C174.009,1152.55 174.457,1153 175.009,1153 C175.562,1153 175.947,1152.47 176.373,1152.05 L179.152,1149.27 C180.922,1151.36 182,1154.05 182,1157 C182,1163.63 176.627,1169 170,1169 C163.373,1169 158,1163.63 158,1157 C158,1151.06 162.327,1146.13 168,1145.18 L168,1141.14 C160.109,1142.12 154,1148.84 154,1157 C154,1165.84 161.164,1173 170,1173 C178.836,1173 186,1165.84 186,1157 C186,1152.94 184.484,1149.25 181.993,1146.43 L184.858,1143.56" ></path>
          </g>
        </g>
      </svg>`,
    
      anonymize: `<svg viewBox="0 -1 28 28" version="1.1" xmlns="http://www.w3.org/2000/svg">
        <title>wind</title>
        <desc>Created with Sketch Beta.</desc>
        <defs></defs>
        <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
          <g transform="translate(-466,-830)" fill="#000000">
            <path d="M488,844 L467,844 C466.447,844 466,844.447 466,845 C466,845.553 466.447,846 467,846 L486.833,846 C489.687,846 492,847.791 492,850 C492,852.209 490.291,854 486,854 L486,856 L488,856 C491.313,856 494,853.313 494,850 C494,846.687 491.313,844 488,844 Z M480.002,848 L480,848 L472,848 C471.447,848 471,848.448 471,849 C471,849.553 471.447,850 472,850 L480,850 C481.104,850 482,850.896 482,852 C482,853.104 481.104,854 480,854 L480,856 C482.209,856 484,854.209 484,852 C484,849.792 482.21,848.002 480.002,848 Z M475,838 L487,838 C487.553,838 488,837.553 488,837 C488,836.448 487.553,836 487,836 L475,836 C474.447,836 474,836.448 474,837 C474,837.553 474.447,838 475,838 Z M470,842 L488,842 C491.313,842 494,839.313 494,836 C494,832.687 491.313,830 488,830 L488,832 C490.822,832.531 492,833.791 492,836 C492,838.209 489.687,840 486.833,840 L470,840 C469.447,840 469,840.448 469,841 C469,841.553 469.447,842 470,842 Z"></path>
          </g>
        </g>
      </svg>`,
    
      help: `<svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M23 12C23 18.0751 18.0751 23 12 23C5.92487 23 1 18.0751 1 12C1 5.92487 5.92487 1 12 1C18.0751 1 23 5.92487 23 12ZM3.00683 12C3.00683 16.9668 7.03321 20.9932 12 20.9932C16.9668 20.9932 20.9932 16.9668 20.9932 12C20.9932 7.03321 16.9668 3.00683 12 3.00683C7.03321 3.00683 3.00683 7.03321 3.00683 12Z" fill="#0F0F0F"/>
        <path d="M13.5 18C13.5 18.8284 12.8284 19.5 12 19.5C11.1716 19.5 10.5 18.8284 10.5 18C10.5 17.1716 11.1716 16.5 12 16.5C12.8284 16.5 13.5 17.1716 13.5 18Z" fill="#0F0F0F"/>
        <path d="M11 12V14C11 14 11 15 12 15C13 15 13 14 13 14V12C13 12 13.4792 11.8629 13.6629 11.7883C13.6629 11.7883 13.9969 11.6691 14.2307 11.4896C14.4646 11.3102 14.6761 11.097 14.8654 10.8503C15.0658 10.6035 15.2217 10.3175 15.333 9.99221C15.4443 9.66693 15.5 9.4038 15.5 9C15.5 8.32701 15.3497 7.63675 15.0491 7.132C14.7596 6.61604 14.3476 6.21786 13.8132 5.93745C13.2788 5.64582 12.6553 5.5 11.9427 5.5C11.4974 5.5 11.1021 5.55608 10.757 5.66825C10.4118 5.7692 10.1057 5.9094 9.83844 6.08887C9.58236 6.25712 9.36525 6.4478 9.18711 6.66091C9.02011 6.86281 8.8865 7.0591 8.78629 7.24978C8.68609 7.44046 8.61929 7.6087 8.58589 7.75452C8.51908 7.96763 8.49125 8.14149 8.50238 8.27609C8.52465 8.41069 8.59145 8.52285 8.70279 8.61258C8.81413 8.70231 8.9867 8.79765 9.22051 8.8986C9.46546 8.97712 9.65473 9.00516 9.78834 8.98273C9.93308 8.96029 10.05 8.89299 10.1391 8.78083C10.1391 8.78083 10.6138 8.10569 10.7474 7.97109C10.8922 7.82528 11.0703 7.71312 11.2819 7.6346C11.4934 7.54487 11.7328 7.5 12 7.5C12.579 7.5 13.0076 7.64021 13.286 7.92062C13.5754 8.18982 13.6629 8.41629 13.6629 8.93225C13.6629 9.27996 13.6017 9.56038 13.4792 9.77349C13.3567 9.9866 13.1953 10.1605 12.9949 10.2951C12.9949 10.2951 12.7227 10.3991 12.5 10.5C12.2885 10.5897 11.9001 10.7381 11.6997 10.8503C11.5104 10.9512 11.4043 11.0573 11.2819 11.2144C11.1594 11.3714 11 11.7308 11 12Z" fill="#0F0F0F"/>
      </svg>`,
        
      placeholderOptions: `<svg viewBox="0 -2 27 27" version="1.1" xmlns="http://www.w3.org/2000/svg">
        <title>shuffle</title>
        <desc>Created with Sketch Beta.</desc>
        <defs></defs>
        <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
          <g transform="translate(-362,-623)" fill="#000000">
            <path d="M384.528,638.166 C384.23,637.871 383.299,637.948 383,638.244 L383,641 L379,641 L375.465,636.161 L374.207,637.792 L378,642.909 L383,642.909 L383,645.781 C383.299,646.076 384.23,645.945 384.528,645.649 L388.771,642.442 C389.069,642.147 389.069,641.669 388.771,641.373 L384.528,638.166 Z M383,628 L383,630.688 C383.299,630.982 384.23,631.105 384.528,630.811 L388.771,627.604 C389.069,627.308 389.069,626.829 388.771,626.534 L384.528,623.326 C384.23,623.031 383.299,622.861 383,623.156 L383,626 L378,626 L367,641 L363,641 C362.447,641 362,641.373 362,641.92 C362,642.466 362.447,643 363,643 L368,643 L379,628 L383,628 L383,628 Z M363,628 L367,628 L370.508,632.803 L371.766,631.172 C371.766,631.172 368.254,626.323 368,626 L363,626 C362.447,626 362,626.534 362,627.08 C362,627.627 362.447,628 363,628 L363,628 Z"></path>
          </g>
        </g>
      </svg>`,
  
      logo: `<svg version="1.0" xmlns="http://www.w3.org/2000/svg"
   width="562.000000pt" height="667.000000pt" viewBox="0 0 562.000000 667.000000"
   preserveAspectRatio="xMidYMid meet">
  
  <g transform="translate(0.000000,667.000000) scale(0.100000,-0.100000)"
  fill="#000000" stroke="none">
  <path d="M2730 6384 c-19 -8 -75 -29 -125 -46 -49 -16 -166 -61 -260 -100 -93
  -38 -321 -128 -505 -199 -184 -72 -389 -152 -455 -179 -184 -74 -649 -256
  -850 -331 l-180 -68 -3 -1068 c-3 -1119 2 -1307 39 -1501 78 -411 213 -740
  453 -1105 142 -216 224 -316 410 -502 288 -287 539 -472 934 -684 192 -103
  574 -281 605 -281 23 0 355 153 557 257 516 264 872 546 1195 943 62 76 83
  105 150 200 222 315 368 624 459 970 78 300 78 293 79 1612 l2 1166 -75 30
  c-41 17 -127 50 -190 73 -266 97 -575 215 -846 322 -159 63 -352 138 -429 167
  -77 29 -199 76 -271 106 -72 29 -180 71 -240 93 -60 21 -169 62 -242 90 -145
  55 -160 58 -212 35z m275 -441 c703 -267 949 -361 1290 -496 105 -41 201 -78
  215 -82 14 -4 98 -36 188 -71 89 -35 168 -64 175 -64 17 0 24 -1919 8 -2087
  -31 -313 -105 -577 -246 -868 -88 -183 -183 -331 -329 -514 -306 -385 -689
  -680 -1199 -926 -167 -80 -294 -135 -313 -135 -23 0 -337 145 -476 220 -180
  97 -396 231 -488 303 -138 109 -318 269 -390 348 -241 265 -424 545 -548 839
  -92 219 -161 497 -182 740 -7 77 -12 499 -13 1101 l-2 975 45 11 c42 10 153
  53 665 256 282 112 446 176 685 267 118 45 283 108 365 141 236 93 316 118
  350 112 17 -3 107 -34 200 -70z"/>
  <path d="M2685 5785 c-60 -24 -177 -70 -260 -103 -276 -110 -513 -202 -520
  -202 -4 0 -91 -33 -194 -74 -464 -183 -649 -254 -746 -287 l-70 -23 2 -941 c2
  -599 6 -980 13 -1050 41 -406 205 -813 469 -1164 160 -213 332 -390 511 -526
  227 -171 385 -266 704 -419 l199 -96 241 119 c400 198 607 334 834 548 338
  319 578 681 710 1074 30 87 65 217 79 295 l27 139 5 1011 6 1012 -135 47 c-74
  26 -207 76 -295 110 -144 57 -459 180 -655 255 -41 16 -187 72 -325 125 -137
  53 -288 110 -335 127 -47 17 -101 38 -120 48 l-35 17 -110 -42z m740 -495 c81
  -7 132 -16 158 -29 22 -11 45 -17 51 -15 7 3 21 -4 31 -16 10 -11 14 -20 10
  -20 -5 0 2 -11 15 -25 24 -25 47 -35 34 -13 -4 7 -3 8 5 4 6 -4 9 -11 6 -16
  -3 -5 79 -91 182 -192 378 -370 411 -404 431 -444 43 -85 46 -142 47 -864 0
  -699 -7 -892 -38 -975 -55 -146 -72 -186 -99 -237 -41 -76 -141 -171 -220
  -208 -105 -49 -178 -63 -305 -58 l-113 4 -55 -58 c-68 -71 -131 -108 -255
  -151 l-95 -32 -470 -3 c-619 -4 -755 10 -920 95 -220 113 -367 274 -453 493
  -26 66 -45 136 -52 190 -7 59 -10 347 -7 935 l3 850 31 116 c35 134 65 204
  128 299 54 82 100 124 212 197 106 69 150 86 305 118 108 21 131 23 191 14 62
  -10 77 -8 160 15 51 14 106 27 122 29 66 9 848 6 960 -3z"/>
  <path d="M3630 5236 c0 -3 9 -10 20 -16 11 -6 20 -8 20 -6 0 3 -9 10 -20 16
  -11 6 -20 8 -20 6z"/>
  <path d="M2502 5149 c-66 -11 -220 -88 -273 -136 -56 -51 -128 -161 -170 -258
  l-33 -80 -9 -940 c-6 -698 -5 -954 4 -995 25 -121 140 -290 234 -346 63 -37
  146 -63 231 -74 41 -5 360 -10 707 -11 609 -1 635 0 690 19 229 81 359 271
  388 567 15 152 7 1487 -9 1526 -5 14 -43 52 -84 85 -40 32 -207 192 -372 354
  l-298 295 -477 1 c-262 1 -500 -2 -529 -7z m910 -158 c4 -3 11 -110 14 -236 8
  -257 9 -263 84 -348 78 -88 90 -91 365 -97 l240 -5 0 -765 0 -765 -23 -67
  c-43 -125 -152 -212 -297 -237 -39 -6 -286 -9 -690 -7 -629 3 -630 3 -690 26
  -76 29 -174 124 -213 208 l-27 57 -3 910 c-2 613 1 933 8 980 12 77 59 171
  116 235 47 52 160 109 237 120 70 10 868 2 879 -9z"/>
  <path d="M2561 4786 c-117 -42 -181 -171 -146 -293 69 -236 409 -206 451 40
  15 90 -48 190 -149 240 -60 29 -102 33 -156 13z m109 -131 c60 -31 78 -99 39
  -149 -17 -22 -28 -26 -69 -26 -42 0 -52 4 -74 31 -37 43 -34 83 8 125 38 38
  54 41 96 19z"/>
  <path d="M2473 4059 c-57 -17 -74 -76 -35 -121 14 -17 62 -18 733 -18 l718 0
  15 22 c30 42 19 91 -25 113 -24 13 -129 15 -701 14 -385 0 -687 -5 -705 -10z"/>
  <path d="M2678 3762 l-217 -2 -26 -31 c-28 -34 -27 -60 4 -92 16 -16 62 -18
  730 -19 l713 -2 24 27 c30 35 30 59 0 94 l-24 28 -494 0 c-271 0 -591 -1 -710
  -3z"/>
  <path d="M2445 3435 c-31 -30 -33 -77 -5 -105 20 -20 33 -20 739 -20 l720 0
  15 22 c23 33 20 75 -9 103 l-24 25 -706 0 -706 0 -24 -25z"/>
  <path d="M2446 3139 c-19 -15 -26 -30 -26 -54 0 -24 7 -39 26 -54 26 -21 34
  -21 725 -21 383 0 705 3 714 6 23 9 47 61 39 87 -3 12 -13 30 -22 40 -14 16
  -61 17 -722 17 -700 0 -708 0 -734 -21z"/>
  <path d="M2445 2835 c-31 -30 -33 -77 -5 -105 18 -18 33 -20 173 -20 83 0 401
  -2 706 -4 l554 -4 29 28 c35 35 36 73 3 105 l-24 25 -706 0 -706 0 -24 -25z"/>
  <path d="M1991 5104 c-97 -21 -162 -55 -229 -121 -84 -83 -167 -249 -181 -368
  -17 -131 -17 -1628 -1 -1846 7 -100 15 -133 50 -225 74 -199 163 -312 299
  -383 141 -73 166 -76 786 -90 480 -11 563 -2 638 68 l41 38 -110 9 c-60 4
  -290 7 -512 6 -258 -2 -417 1 -442 8 -22 6 -110 45 -197 87 -143 69 -165 83
  -231 148 -39 40 -79 89 -87 109 -28 67 -55 230 -71 433 -15 179 -15 283 -6
  890 12 756 15 803 73 918 39 76 55 94 128 134 48 27 65 44 92 93 19 33 46 67
  61 76 16 9 28 20 28 24 0 12 -56 8 -129 -8z"/>
  </g>
  </svg>`,
      // Hinzugefügte Icons:
      spinner: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 100 100" preserveAspectRatio="xMidYMid">
        <circle cx="50" cy="50" fill="none" stroke="#000" stroke-width="10" r="35" stroke-dasharray="164.93361431346415 56.97787143782138">
          <animateTransform attributeName="transform" type="rotate" repeatCount="indefinite" dur="1s" values="0 50 50;360 50 50" keyTimes="0;1"></animateTransform>
        </circle>
      </svg>`,
  
      check: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="green">
        <path d="M20.285,6.709l-11.999,12l-5.285-5.285l1.415-1.414l3.87,3.87l10.584-10.584L20.285,6.709z"/>
      </svg>`
    };
})(window);

</script>
    <script>
"use strict";

// Helper to escape regex special characters.
function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

/* Base class for detection strategies */
class DetectionStrategy {
  detect(text, currentMapping) {
    throw new Error("detect() not implemented");
  }
}

/* Regex detection strategy with optional prefixes and suffixes */
class RegexDetectionStrategy extends DetectionStrategy {
  /**
   * Options:
   *   - regex: RegExp for the main pattern.
   *   - description: Description of the strategy.
   *   - groupIndex: Capture group index for the main match (default 0).
   *   - prefixes: Optional array of strings that must precede the main match.
   *   - suffixes: Optional array of strings that must follow the main match.
   */
  constructor(options) {
    super();
    this.description = options.description;
    this.groupIndex = options.groupIndex || 0;
    if (options.prefixes || options.suffixes) {
      let pattern = "";
      if (options.prefixes) {
        const prefixPattern = options.prefixes.map(escapeRegExp).join("|");
        pattern += "(?:" + prefixPattern + ")\\s*";
      }
      pattern += "(" + options.regex.source + ")";
      if (options.suffixes) {
        const suffixPattern = options.suffixes.map(escapeRegExp).join("|");
        pattern += "\\s*(?:" + suffixPattern + ")";
      }
      this.regex = new RegExp(pattern, options.regex.flags);
      this.groupIndex = 1;
    } else {
      this.regex = options.regex;
    }
  }

  detect(text, currentMapping) {
    const results = [];
    const regex = new RegExp(this.regex.source, this.regex.flags);
    let m;
    while ((m = regex.exec(text)) !== null) {
      const detectedValue = m[this.groupIndex] || m[0];
      if (!detectedValue) continue;
      if (currentMapping.some(e => e.original === detectedValue && e.strategy === this))
        continue;
      // Calculate the start index of the captured group within the overall match.
      let offset = m[0].indexOf(detectedValue);
      if (offset < 0) offset = 0;
      const start = m.index + offset;
      const end = start + detectedValue.length;
      results.push({
        original: detectedValue,
        token: null,
        strategy: this,
        rank: 1,
        start: start,
        end: end
      });
    }
    return results;
  }
}

/* Generic placeholder type that aggregates multiple detection strategies */
class GenericPlaceholderType {
  constructor(placeholderPrefix, detectionStrategies = []) {
    this.placeholderPrefix = placeholderPrefix;
    this.detectionStrategies = detectionStrategies;
    this.rank = 1;
  }

  getNextTokenName(currentMapping) {
    let token = `[${this.placeholderPrefix}]`;
    if (!currentMapping.some(e => e.token === token)) return token;
    let counter = 2;
    token = `[${this.placeholderPrefix}_${counter}]`;
    while (currentMapping.some(e => e.token === token)) {
      counter++;
      token = `[${this.placeholderPrefix}_${counter}]`;
    }
    return token;
  }

  // Run all detection strategies and clean the results.
  detect(text, currentMapping) {
    let results = [];
    for (const strategy of this.detectionStrategies) {
      const detected = strategy.detect(text, currentMapping);
      results = results.concat(detected);
    }
    return this.cleanMatches(results);
  }

  // Remove duplicate matches and those completely overlapped by another.
  cleanMatches(matches) {
    const unique = [];
    for (const m of matches) {
      if (!unique.some(u => u.start === m.start && u.end === m.end))
        unique.push(m);
    }
    return unique.filter(m =>
      !unique.some(other => other !== m && other.start <= m.start && other.end >= m.end)
    );
  }
}

/* Placeholder for detecting names using regex with prefixes */
class NamePlaceholder extends GenericPlaceholderType {
  constructor() {
    // Define common prefixes that must appear before a name.
    const prefixes = [
      "Mit freundlichen Grüßen,?",
      "Liebe Grüße,?",
      "Viele Grüße,?",
      "Best regards,?",
      "Cordialement,?",
      "Guten Morgen",
      "Guten Tag",
      "Hallo",
      "Liebe",
      "Lieber",
      "Moin",
      "Grüß dich",
      "Servus",
      "Sehr geehrte(r)? (?:Herr|Frau)",
      "Herr",
      "Herrn",
      "Frau",
      "Prof\\.",
      "Dr\\.",
      "Dear Mr\\.",
      "Dear Mrs\\.",
      "Dear Ms\\.",
      "Dear Miss",
      "Hello",
      "Hi",
      "Hey",
      "Greetings",
      "Chère(?: Monsieur| Madame)?",
      "Salut",
      "Monsieur",
      "Madame",
      "Estimado(?: Sr\\.?| Señor|Señora)?",
      "Hola",
      "Querido",
      "Querida",
      "Saludos cordiales,?"
    ];
    // Pattern for a name: one token with optional additional parts.
    const namePattern = "[A-ZÄÖÜÀ-ÖØ-Ý][a-zäöüßà-öø-ÿ]+(?:-[A-ZÄÖÜÀ-ÖØ-Ý][a-zäöüßà-öø-ÿ]+)?(?:\\s+[A-ZÄÖÜÀ-ÖØ-Ý][a-zäöüßà-öø-ÿ]+){0,2}";
    const nameStrategy = new RegexDetectionStrategy({
      regex: new RegExp(namePattern, "g"),
      description: "Name detection with prefixes",
      groupIndex: 0,
      prefixes: prefixes
    });
    super("Name", [nameStrategy]);
  }
}

/* Placeholder for detecting numbers using a regex */
class NumberPlaceholder extends GenericPlaceholderType {
  constructor() {
    const numberRegex = /(?<!\d)[1-9](?:[ .\-\/\\]*\d){3,}(?!\d)/g;
    const numberStrategy = new RegexDetectionStrategy({
      regex: numberRegex,
      description: "Number detection",
      groupIndex: 0
    });
    super("Number", [numberStrategy]);
  }
}

window.DetectionStrategy = DetectionStrategy;
window.RegexDetectionStrategy = RegexDetectionStrategy;
window.GenericPlaceholderType = GenericPlaceholderType;
window.NamePlaceholder = NamePlaceholder;
window.NumberPlaceholder = NumberPlaceholder;

</script>
    <script>
"use strict";

/**
 * Returns a 2-digit string for a given number.
 * Example: pad2(5) returns "05"
 */
function pad2(n) {
  return n < 10 ? "0" + n : "" + n;
}

/**
 * Returns an array of full month names for the specified language.
 * Supported language codes: "deu", "en", "fr", "es"
 */
function getMonthNames(language) {
  switch (language) {
    case "deu":
      return [
        "Januar", "Februar", "März", "April", "Mai", "Juni",
        "Juli", "August", "September", "Oktober", "November", "Dezember"
      ];
    case "en":
      return [
        "January", "February", "March", "April", "May", "June",
        "July", "August", "September", "October", "November", "December"
      ];
    case "fr":
      return [
        "janvier", "février", "mars", "avril", "mai", "juin",
        "juillet", "août", "septembre", "octobre", "novembre", "décembre"
      ];
    case "es":
      return [
        "enero", "febrero", "marzo", "abril", "mayo", "junio",
        "julio", "agosto", "septiembre", "octubre", "noviembre", "diciembre"
      ];
    default:
      throw new Error("Unsupported language: " + language);
  }
}

/**
 * Returns an array of abbreviated month names for the specified language.
 * Supported language codes: "deu", "en", "fr", "es"
 */
function getAbbreviatedMonthNames(language) {
  switch (language) {
    case "deu":
      return ["Jan.", "Feb.", "Mär.", "Apr.", "Mai", "Jun.", "Jul.", "Aug.", "Sep.", "Okt.", "Nov.", "Dez."];
    case "en":
      return ["Jan.", "Feb.", "Mar.", "Apr.", "May", "Jun.", "Jul.", "Aug.", "Sep.", "Oct.", "Nov.", "Dec."];
    case "fr":
      return ["jan.", "fév.", "mars", "avr.", "mai", "juin", "juil.", "août", "sep.", "oct.", "nov.", "déc."];
    case "es":
      return ["ene.", "feb.", "mar.", "abr.", "may.", "jun.", "jul.", "ago.", "sept.", "oct.", "nov.", "dic."];
    default:
      throw new Error("Unsupported language: " + language);
  }
}

/**
 * An array of date format definitions.
 * Each format has a description, an example, a regex pattern for matching,
 * and a function to format a Date object accordingly.
 */
const dateFormats = [
  {
    description: "dd.mm.yyyy",
    example: "31.12.2020",
    pattern: "\\b\\d{2}\\.\\d{1,2}\\.\\d{4}\\b",
    format: d => pad2(d.getDate()) + "." + pad2(d.getMonth() + 1) + "." + d.getFullYear()
  },
  {
    description: "m/yyyy",
    example: "1/2020",
    pattern: "\\b\\d{1,2}\\/\\d{4}\\b",
    format: d => (d.getMonth() + 1) + "/" + d.getFullYear()
  },
  {
    description: "dd. Monatsname Jahr (de) – voll",
    example: "31. Dezember 2020",
    pattern: `\\b\\d{1,2}\\.\\s+(?:(?:${getMonthNames("deu").join("|")})|(?:${getAbbreviatedMonthNames("deu").join("|")}))\\s\\d{4}\\b`,
    format: d => pad2(d.getDate()) + ". " + getMonthNames("deu")[d.getMonth()] + " " + d.getFullYear()
  },
  {
    description: "Monatsname",
    example: "November",
    pattern: `\\b(?:(?:${getMonthNames("deu").join("|")})|(?:${getAbbreviatedMonthNames("deu").join("|")}))(?=\\s|$)`,
    format: d => getMonthNames("deu")[d.getMonth()]
  },
  {
    description: "Monatsname yyyy (de)",
    example: "November 2020",
    pattern: `\\b(?:(?:${getMonthNames("deu").join("|")})|(?:${getAbbreviatedMonthNames("deu").join("|")}))\\s\\d{4}\\b`,
    format: d => getMonthNames("deu")[d.getMonth()] + " " + d.getFullYear()
  },
  {
    description: "Month Day, Year (en)",
    example: "December 31, 2020",
    pattern: `\\b(?:${getMonthNames("en").join("|")})\\s\\d{1,2},\\s\\d{4}\\b`,
    format: d => getMonthNames("en")[d.getMonth()] + " " + d.getDate() + ", " + d.getFullYear()
  },
  {
    description: "YYYY-MM-DD",
    example: "2020-12-31",
    pattern: "\\b\\d{4}-\\d{1,2}-\\d{1,2}\\b",
    format: d => d.getFullYear() + "-" + pad2(d.getMonth() + 1) + "-" + pad2(d.getDate())
  },
  {
    description: "Context: Jahr YYYY (de/en/fr)",
    example: "Jahr 1989",
    pattern: "\\b(?:Jahr|in|year|en|année)\\s+([12]\\d{3})\\b",
    format: d => "Jahr " + d.getFullYear().toString()
  },
  {
    description: "dd.MM. (de) – ohne Jahr",
    example: "31.12.",
    pattern: "\\b\\d{2}\\.\\d{2}(?:\\.)?(?=\\s|$)",
    format: d => pad2(d.getDate()) + "." + pad2(d.getMonth() + 1) + "."
  },
  {
    description: "Month Day (en) – ohne Jahr",
    example: "November 27",
    pattern: `\\b(?:${getMonthNames("en").join("|")})\\s\\d{1,2}\\b`,
    format: d => getMonthNames("en")[d.getMonth()] + " " + d.getDate()
  },
  {
    description: "dd MMMM (fr) – ohne Jahr",
    example: "31 décembre",
    pattern: `\\b\\d{1,2}\\s(?:${getMonthNames("fr").join("|")})\\b`,
    format: d => d.getDate() + " " + getMonthNames("fr")[d.getMonth()]
  },
  {
    description: "dd de MMMM (es) – ohne Jahr",
    example: "31 de diciembre",
    pattern: `\\b\\d{1,2}\\sde\\s(?:${getMonthNames("es").join("|")})\\b`,
    format: d => d.getDate() + " de " + getMonthNames("es")[d.getMonth()]
  },
  {
    description: "MM/DD/YYYY (en, US)",
    example: "12/31/2020",
    pattern: "\\b(0?[1-9]|1[0-2])\\/(0?[1-9]|[12][0-9]|3[01])\\/(\\d{4})\\b",
    format: d => pad2(d.getMonth() + 1) + "/" + pad2(d.getDate()) + "/" + d.getFullYear()
  },
  {
    description: "MMM dd, yyyy (en, abbreviated)",
    example: "Dec 31, 2020",
    pattern: `\\b(?:${getAbbreviatedMonthNames("en").join("|")})\\s\\d{1,2},\\s\\d{4}\\b`,
    format: d => getAbbreviatedMonthNames("en")[d.getMonth()] + " " + pad2(d.getDate()) + ", " + d.getFullYear()
  },
  {
    description: "dd MMMM yyyy (fr)",
    example: "31 décembre 2020",
    pattern: `\\b\\d{1,2}\\s(?:${getMonthNames("fr").join("|")})\\s\\d{4}\\b`,
    format: d => pad2(d.getDate()) + " " + getMonthNames("fr")[d.getMonth()] + " " + d.getFullYear()
  },
  {
    description: "dd MMM yyyy (fr, abbreviated)",
    example: "31 déc. 2020",
    pattern: `\\b\\d{1,2}\\s(?:${getAbbreviatedMonthNames("fr").join("|")})\\s\\d{4}\\b`,
    format: d => pad2(d.getDate()) + " " + getAbbreviatedMonthNames("fr")[d.getMonth()] + " " + d.getFullYear()
  },
  {
    description: "dd 'de' MMMM 'de' yyyy (es)",
    example: "31 de diciembre de 2020",
    pattern: `\\b\\d{1,2}\\sde\\s(?:${getMonthNames("es").join("|")})\\sde\\s\\d{4}\\b`,
    format: d => pad2(d.getDate()) + " de " + getMonthNames("es")[d.getMonth()] + " de " + d.getFullYear()
  },
  {
    description: "dd MMM yyyy (es, abbreviated)",
    example: "31 dic. 2020",
    pattern: `\\b\\d{1,2}\\s(?:${getAbbreviatedMonthNames("es").join("|")})\\s\\d{4}\\b`,
    format: d => pad2(d.getDate()) + " " + getAbbreviatedMonthNames("es")[d.getMonth()] + " " + d.getFullYear()
  }
];

// Expose helper functions and dateFormats to the global scope.
(function (window) {
  window.pad2 = pad2;
  window.getMonthNames = getMonthNames;
  window.getAbbreviatedMonthNames = getAbbreviatedMonthNames;
  window.dateFormats = dateFormats;
})(window);

</script>
    <script>
"use strict";

(function (window) {
  // Simple text wrapper with change notification.
  class TextWrapper {
    constructor(initialText = "") {
      this.text = initialText;
      this._onTextChange = null;
    }
    get() {
      return this.text;
    }
    set(newText) {
      this.text = newText;
      if (this._onTextChange) {
        this._onTextChange(newText);
      }
    }
    setOnTextChange(callback) {
      this._onTextChange = callback;
    }
  }

  class Anonymizer {
    constructor(initialText = "") {
      // Updated placeholder types: use new NamePlaceholder and NumberPlaceholder
      this.placeholderTypes = [
        new NumberPlaceholder(),       // new integrated placeholder for numbers
        new NamePlaceholder(),         // new integrated placeholder for names
      ];
      this.whitelist = [];
      this._wlMapping = {};
      this._wlCounter = 1;
      this.scanCompleted = false;
      // Mapping entries: [original, token, placeholder, rank]
      this.mapping = [];
      this._abortController = null;

      // Callback properties
      this._onProgress = null;
      this._onMappingChange = null;
      this._onComplete = null;
      this._onAbort = null;
      this._onTextChange = null;

      this.textWrapper = new TextWrapper(initialText);
      this.textWrapper.setOnTextChange(() => this._triggerTextChange());
    }

    // Callback setters
    setOnProgress(callback) { this._onProgress = callback; }
    setOnMappingChange(callback) { this._onMappingChange = callback; }
    setOnComplete(callback) { this._onComplete = callback; }
    setOnAbort(callback) { this._onAbort = callback; }
    setOnTextChange(callback) { this._onTextChange = callback; }

    // Trigger progress callback
    _triggerProgress(percent, message) {
      if (this._onProgress) this._onProgress(percent, message);
    }
    _triggerMappingChange() {
      if (this._onMappingChange) this._onMappingChange();
    }
    _triggerComplete(mapping) {
      if (this._onComplete) this._onComplete(mapping);
    }
    _triggerAbort() {
      if (this._onAbort) this._onAbort();
    }
    _triggerTextChange() {
      if (this._onTextChange) this._onTextChange();
    }

    // Set text and apply whitelist, then clean mapping list.
    setText(newText = "") {
      const processedText = this._applyWhitelist(newText);
      this.textWrapper.set(processedText);
      this.cleanMappingList();
    }

    // Replace whitelist items with tokens.
    _applyWhitelist(newText) {
      this._wlMapping = {};
      this._wlCounter = 1;
      // Sort whitelist items by length descending.
      const sortedWL = [...this.whitelist].sort((a, b) => b.length - a.length);
      sortedWL.forEach(wl => {
        const token = `[!WL!${this._wlCounter++}]`;
        const escaped = window.Utils.escapeRegExp(wl);
        newText = newText.replace(new RegExp(escaped, "g"), token);
        this._wlMapping[token] = wl;
      });
      return newText;
    }

    // Restore whitelist tokens.
    _restoreWhitelist(text) {
      for (const token in this._wlMapping) {
        const wlValue = this._wlMapping[token];
        text = text.replace(new RegExp(window.Utils.escapeRegExp(token), "g"), wlValue);
      }
      return text;
    }

    // Scan text for sensitive data using new detection strategies.
    async identifyPII() {
      if (this._abortController) {
        this._abortController.abort();
        this._triggerAbort();
      }
      this._abortController = new AbortController();
      const signal = this._abortController.signal;
      this.scanCompleted = false;
      const originalText = this.textWrapper.get();
      // Filter active placeholders; assume each has an 'enabled' property (default true).
      const activePlaceholders = this.placeholderTypes.filter(ph => ph.enabled !== false)
                                  .sort((a, b) => (a.rank || 0) - (b.rank || 0));
      for (let i = 0; i < activePlaceholders.length; i++) {
        if (signal.aborted) return;
        const ph = activePlaceholders[i];
        const percent = Math.round(((i + 1) / activePlaceholders.length) * 100);
        this._triggerProgress(percent, `Scanning for ${ph.placeholderPrefix}...`);
        // Use the new detect method from the placeholder.
        const results = ph.detect(originalText, this.mapping) || [];
        results.forEach(result => {
          // Add detection result to mapping list.
          this.addToMappingList(result.original, result.token, ph, ph.rank);
        });
      }
      this.cleanMappingList();
      this._triggerComplete(this.mapping);
      this.scanCompleted = true;
      this._abortController = null;
      console.log("PII identification completed.");
    }

    // Add a new mapping entry. Removes entries with the same original text.
    addToMappingList(original, token, placeholder, rank) {
      this.mapping = this.mapping.filter(entry => entry[0] !== original);
      this.mapping.push([original, token, placeholder, rank]);
      this._triggerMappingChange();
    }

    // Apply anonymization by assigning tokens and replacing sensitive data.
    _applyAnonymization(text, mappingList) {
      let modifiedText = text;
      const updatedMappingList = mappingList.map(entry => [...entry]);
      updatedMappingList.sort((a, b) => {
        if (a[3] === b[3]) {
          return b[0].length - a[0].length;
        }
        return a[3] - b[3];
      });
      updatedMappingList.forEach(entry => {
        const [original, token, placeholder] = entry;
        const regex = new RegExp(window.Utils.escapeRegExp(original), "g");
        if (regex.test(modifiedText)) {
          if (token === null) {
            entry[1] = placeholder.getNextTokenName(updatedMappingList);
          }
          modifiedText = modifiedText.replace(regex, entry[1]);
        }
      });
      return { modifiedText, updatedMappingList };
    }

    // Replace sensitive data with tokens.
    async anonymize() {
      if (!this.scanCompleted) {
        await this.identifyPII();
      }
      const { modifiedText, updatedMappingList } =
        this._applyAnonymization(this.textWrapper.get(), this.mapping);
      this.mapping = updatedMappingList;
      this.setText(modifiedText);
      return this.textWrapper.get();
    }

    // Replace tokens with original sensitive data.
    deanonymize() {
      let text = this.textWrapper.get();
      this.mapping.forEach(entry => {
        if (entry[1] !== null) {
          text = text.replace(new RegExp(window.Utils.escapeRegExp(entry[1]), "g"), entry[0]);
        }
      });
      this.setText(text);
      return this.textWrapper.get();
    }

    // Return final text with whitelist restored.
    getText() {
      return this._restoreWhitelist(this.textWrapper.get());
    }

    clearMapping() {
      this.mapping = [];
      this._triggerMappingChange();
    }

    getMapping() {
      return this.mapping;
    }

    // Clean mapping list by removing invalid or duplicate entries.
    cleanMappingList() {
      const { updatedMappingList } = this._applyAnonymization(this.textWrapper.get(), this.mapping);
      this.mapping = this.mapping.filter(entry => {
        if (!entry[2].enabled) return false;
        if (entry[1] !== null) return true;
        return updatedMappingList.some(simEntry =>
          simEntry[0] === entry[0] &&
          simEntry[2] === entry[2] &&
          simEntry[1] !== null
        );
      });
      this._triggerMappingChange();
    }

    // Add item to whitelist and re-run detection.
    addToWhitelist(item) {
      if (!this.whitelist.includes(item)) {
        this.whitelist.push(item);
        this.setText(this.getText());
        this.identifyPII();
      }
    }

    removeFromWhitelist(item) {
      this.whitelist = this.whitelist.filter(wl => wl !== item);
      this.setText(this.getText());
      this.identifyPII();
    }

    addCustomPlaceholder(label, pattern, direct = false) {
      let uniqueLabel;
      if (this.placeholderTypes.some(ph => ph.placeholderPrefix === label)) {
        let counter = 1;
        uniqueLabel = label + counter;
        while (this.placeholderTypes.some(ph => ph.placeholderPrefix === uniqueLabel)) {
          counter++;
          uniqueLabel = label + counter;
        }
      } else {
        uniqueLabel = label;
      }
      const customPlaceholder = new CustomPlaceholderType(pattern, uniqueLabel);
      this.placeholderTypes.push(customPlaceholder);

      const currentText = this.textWrapper.get();
      const results = customPlaceholder.identifyPII
                        ? customPlaceholder.identifyPII(currentText, this.mapping) || []
                        : [];
      results.forEach(entry => {
        this.addToMappingList(entry[0], entry[1], customPlaceholder, customPlaceholder.rank);
      });

      if (direct && typeof customPlaceholder.apply === 'function') {
        customPlaceholder.apply();
      }
    }

    getUniqueSecretLabel() {
      let maxNum = 0;
      this.placeholderTypes.forEach(ph => {
        if (ph.placeholderPrefix.startsWith("Secret")) {
          const num = parseInt(ph.placeholderPrefix.slice(6), 10);
          if (!isNaN(num) && num > maxNum) maxNum = num;
        }
      });
      return "Secret" + (maxNum + 1);
    }

    getPlaceholderByID(id) {
      return this.placeholderTypes.find(ph => ph.id === id);
    }

    removePlaceholder(id) {
      const ph = this.getPlaceholderByID(id);
      if (!ph) return;
      let currentText = this.textWrapper.get();
      this.mapping.forEach(entry => {
        if (entry[2].id === ph.id && entry[1] !== null) {
          const regex = new RegExp(this._escapeRegExp(entry[1]), "g");
          currentText = currentText.replace(regex, entry[0]);
        }
      });
      this.mapping = this.mapping.filter(entry => entry[2].id !== ph.id);
      if (ph.isCustom) {
        const index = this.placeholderTypes.findIndex(item => item.id === ph.id);
        if (index !== -1) this.placeholderTypes.splice(index, 1);
      } else {
        ph.enabled = false;
      }
      this.textWrapper.set(currentText);
      this.identifyPII();
    }

    setPlaceholderStatus(id, status) {
      const ph = this.getPlaceholderByID(id);
      if (ph) {
        ph.enabled = status;
        this.identifyPII();
      }
    }
    
    // Singular anonymization: replace all occurrences of a specific original text.
    anonymizeSingleText(originalText) {
      let mappingEntry = this.mapping.find(entry => entry[0] === originalText);
      if (!mappingEntry) return;
      const regex = new RegExp(window.Utils.escapeRegExp(originalText), "g");
      let currentText = this.textWrapper.get();
      if (mappingEntry[1] === null) {
        mappingEntry[1] = mappingEntry[2].getNextTokenName(this.mapping);
      }
      currentText = currentText.replace(regex, mappingEntry[1]);
      this.setText(currentText);
      this._triggerTextChange();
    }
    
    // Singular deanonymization: replace a specific token with its original text.
    deanonymizeSingleToken(token) {
      let mappingEntry = this.mapping.find(entry => entry[1] === token);
      if (!mappingEntry) return;
      let currentText = this.textWrapper.get();
      const regex = new RegExp(window.Utils.escapeRegExp(token), "g");
      currentText = currentText.replace(regex, mappingEntry[0]);
      this.setText(currentText);
      this._triggerTextChange();
    }
    
  }

  window.Anonymizer = Anonymizer;
  window.TextWrapper = TextWrapper;
  
  // Compatibility alias for existing calls.
  Anonymizer.prototype.deanonymize_singleToken = Anonymizer.prototype.deanonymizeSingleToken;
  Anonymizer.prototype.anonymize_singleText = Anonymizer.prototype.anonymizeSingleText;
})(window);

window.anonymizer = new Anonymizer();

</script>
    <script>
/**
 * utils.js
 * General utility functions for string manipulation, DOM element creation, and throttling.
 */
(function (window) {
  "use strict";

  // Escape HTML special characters to prevent XSS issues.
  function escapeHtml(unsafe) {
    return unsafe
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#039;");
  }

  // Escape special characters in a string for use in a regular expression.
  function escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  }

  // Create a button element with a given label and click callback.
  function createButton(label, callback, className) {
    var btn = document.createElement("button");
    btn.textContent = label;
    if (className) {
      btn.classList.add(className);
    }
    btn.addEventListener("click", callback);
    return btn;
  }

  // Throttle the execution of a function by the specified delay (in ms).
  function throttle(callback, delay) {
    var lastCall = 0;
    var timeoutId = null;
    var lastArgs = null;

    function throttled() {
      lastArgs = arguments;
      var now = Date.now();
      var remaining = delay - (now - lastCall);
      if (remaining <= 0) {
        if (timeoutId) {
          clearTimeout(timeoutId);
          timeoutId = null;
        }
        lastCall = now;
        callback.apply(null, lastArgs);
      } else if (!timeoutId) {
        timeoutId = setTimeout(function () {
          lastCall = Date.now();
          timeoutId = null;
          callback.apply(null, lastArgs);
        }, remaining);
      }
    }

    throttled.flush = function () {
      if (timeoutId) {
        clearTimeout(timeoutId);
        timeoutId = null;
        lastCall = Date.now();
        callback.apply(null, lastArgs);
      }
    };

    return throttled;
  }

  // Get all match intervals for a search string within a given text.
  function getMatchIntervals(text, searchString, className) {
    var intervals = [];
    var start = 0;
    while (true) {
      var index = text.indexOf(searchString, start);
      if (index === -1) break;
      intervals.push({ start: index, end: index + searchString.length, className: className });
      start = index + 1;
    }
    return intervals;
  }

  // Merge overlapping intervals.
  function mergeOverlappingIntervals(intervals) {
    if (!intervals.length) return [];
    intervals.sort(function (a, b) {
      return a.start - b.start;
    });
    var merged = [intervals[0]];
    for (var i = 1; i < intervals.length; i++) {
      var last = merged[merged.length - 1];
      if (intervals[i].start <= last.end) {
        last.end = Math.max(last.end, intervals[i].end);
      } else {
        merged.push(intervals[i]);
      }
    }
    return merged;
  }

  // Collect match intervals for an array of search strings.
  function collectIntervals(text, matches, className) {
    return matches.reduce(function (acc, match) {
      return acc.concat(getMatchIntervals(text, match, className));
    }, []);
  }

  // Expose utility functions under the global 'Utils' namespace.
  window.Utils = {
    escapeHtml: escapeHtml,
    escapeRegExp: escapeRegExp,
    createButton: createButton,
    throttle: throttle,
    getMatchIntervals: getMatchIntervals,
    mergeOverlappingIntervals: mergeOverlappingIntervals,
    collectIntervals: collectIntervals
  };
})(window);

</script>
    <script>
"use strict";

(function (window) {
  document.addEventListener("DOMContentLoaded", function () {
    // Ensure window.Icons is defined with the required properties.
    window.Icons = window.Icons || {
      anonymize: "🛡️",
      deanonymize: "👀",
      check: "✅",
      addPlaceholder: "➕",
      options: "🛠️",
      help: "💡",
      logo: "", // Set your logo icon if needed
      mapping: "📋"
    };

    // -----------------------------
    // Language and Translation Setup
    // -----------------------------
    const languageSelect = document.getElementById("languageSelect");
    if (languageSelect) {
      languageSelect.value = window.Config.get("language");
      languageSelect.addEventListener("change", function (e) {
        window.Config.set("language", e.target.value);
        updateLanguage();
      });
    }
    function updateLanguage() {
      const lang = window.Config.get("language") || "en";
      // Für normale Textinhalte:
      document.querySelectorAll("[data-i18n]").forEach(el => {
        const key = el.getAttribute("data-i18n");
        if (window.translations && window.translations[lang] && window.translations[lang][key]) {
          el.textContent = window.translations[lang][key];
        }
      });
      // Für HTML-Inhalte (z.B. Version-Text mit GitHub-Link):
      document.querySelectorAll("[data-i18n-html]").forEach(el => {
        const key = el.getAttribute("data-i18n-html");
        if (window.translations && window.translations[lang] && window.translations[lang][key]) {
          let trans = window.translations[lang][key];
          if (window.appVersion) {
            trans = trans.replace("{0}", window.appVersion);
          }
          el.innerHTML = trans;
        }
      });
      // Update von alt/title/placeholder wie gehabt...
      document.querySelectorAll("[data-i18n-alt]").forEach(el => {
        const key = el.getAttribute("data-i18n-alt");
        if (window.translations && window.translations[lang] && window.translations[lang][key]) {
          const translation = window.translations[lang][key];
          el.setAttribute("title", translation);
          el.setAttribute("aria-label", translation);
        }
      });
      document.querySelectorAll("[data-i18n-placeholder]").forEach(el => {
        const key = el.getAttribute("data-i18n-placeholder");
        if (window.translations && window.translations[lang] && window.translations[lang][key]) {
          el.placeholder = window.translations[lang][key];
        }
      });
      // Editor-Update etc.
      const editor = document.getElementById("editor");
      if (editor) {
        editor.dispatchEvent(new Event("input"));
      }
    }
    window.updateLanguage = updateLanguage;
    updateLanguage();


    // -----------------------------
    // Modal Close Button Handlers using window.Modal functions
    // -----------------------------
    const closeSettingsModalBtn = document.getElementById("closeSettingsModalBtn");
    const closeGeneralModalBtn = document.getElementById("closeGeneralModalBtn");
    const closeHelpModalBtn = document.getElementById("closeHelpModalBtn");
    const closeMappingModalBtn = document.getElementById("closeMappingModalBtn");
    if (closeSettingsModalBtn) {
      closeSettingsModalBtn.addEventListener("click", function () {
        window.Modal.hideModal("settingsModal");
      });
    }
    if (closeGeneralModalBtn) {
      closeGeneralModalBtn.addEventListener("click", function () {
        window.Modal.hideModal("generalModal");
      });
    }
    if (closeHelpModalBtn) {
      closeHelpModalBtn.addEventListener("click", function () {
        window.Modal.hideModal("helpModal");
      });
    }
    if (closeMappingModalBtn) {
      closeMappingModalBtn.addEventListener("click", function () {
        window.Modal.hideModal("mappingModal");
      });
    }
    window.addEventListener("click", function (event) {
      const mappingModal = document.getElementById("mappingModal");
      if (event.target === mappingModal) {
        window.Modal.hideModal("mappingModal");
      }
    });


    // -----------------------------
    // Header and Side Menu Setup
    // -----------------------------
    const headerLogo = document.getElementById("headerLogo");
    if (headerLogo && window.Icons && window.Icons.logo) {
      headerLogo.innerHTML = window.Icons.logo;
    }
    const headerAddBtn = document.getElementById("headerAddPlaceholder");
    const headerSettingsBtn = document.getElementById("headerSettings");
    const headerGeneralBtn = document.getElementById("headerGeneral");
    const headerHelpBtn = document.getElementById("headerHelp");
    const headerMappingBtn = document.getElementById("headerMapping");
    const downloadProgramBtn = document.getElementById("downloadProgramBtn");

    if (headerAddBtn && window.Icons && window.Icons.addPlaceholder) {
      headerAddBtn.addEventListener("click", function () {
        window.Modal.openCustomPlaceholderModal("");
      });
    }
    if (headerSettingsBtn && window.Icons && window.Icons.options) {
      headerSettingsBtn.addEventListener("click", function () {
        window.Modal.showModal("settingsModal");
        window.Modal.updatePlaceholderOptions();
      });
    }
    if (headerGeneralBtn) {
      headerGeneralBtn.addEventListener("click", function () {
        window.Modal.showModal("generalModal");
      });
    }
    if (headerHelpBtn && window.Icons && window.Icons.help) {
      headerHelpBtn.addEventListener("click", function () {
        window.Modal.showModal("helpModal");
      });
    }
    if (headerMappingBtn) {
      headerMappingBtn.addEventListener("click", function () {
        updateMappingModal();
        window.Modal.showModal("mappingModal");
      });
    }
    if (downloadProgramBtn) {
      downloadProgramBtn.addEventListener("click", async function () {
        const configBlock = `<!-- CONFIG-START -->
<script>
  window.AppConfig = ${JSON.stringify(window.Config.config, null, 2)};
<\/script>
<!-- CONFIG-END -->`;
        let finalHtml = "<!DOCTYPE html>\n" + document.documentElement.outerHTML;
        finalHtml = finalHtml.replace(/<!--\s*CONFIG-START[\s\S]*?CONFIG-END\s*-->/, configBlock);
        if (window.showSaveFilePicker) {
          try {
            const opts = {
              types: [{
                description: "HTML Files",
                accept: { "text/html": [".html"] }
              }]
            };
            const handle = await window.showSaveFilePicker(opts);
            const writable = await handle.createWritable();
            await writable.write(finalHtml);
            await writable.close();
          } catch (err) {
            console.error("Save cancelled", err);
          }
        } else {
          const blob = new Blob([finalHtml], { type: "text/html" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = "programm.html";
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        }
      });
    }

    // -----------------------------
    // Side Menu for Small Screens
    // -----------------------------
    const openMenuBtn = document.getElementById("openMenu");
    const closeMenuBtn = document.getElementById("closeMenu");
    const sideMenu = document.getElementById("sideMenu");
    if (openMenuBtn) {
      openMenuBtn.addEventListener("click", function () {
        sideMenu.classList.add("open");
      });
    }
    if (closeMenuBtn) {
      closeMenuBtn.addEventListener("click", function () {
        sideMenu.classList.remove("open");
      });
    }
    const menuAddPlaceholder = document.getElementById("menuAddPlaceholder");
    const menuSettings = document.getElementById("menuSettings");
    const menuGeneral = document.getElementById("menuGeneral");
    const menuHelp = document.getElementById("menuHelp");
    const menuMapping = document.getElementById("menuMapping");
    const menuDownload = document.getElementById("menuDownload");
    if (menuAddPlaceholder) {
      menuAddPlaceholder.addEventListener("click", function (e) {
        e.preventDefault();
        window.Modal.openCustomPlaceholderModal("");
        sideMenu.classList.remove("open");
      });
    }
    if (menuSettings) {
      menuSettings.addEventListener("click", function (e) {
        e.preventDefault();
        window.Modal.showModal("settingsModal");
        window.Modal.updatePlaceholderOptions();
        sideMenu.classList.remove("open");
      });
    }
    if (menuGeneral) {
      menuGeneral.addEventListener("click", function (e) {
        e.preventDefault();
        window.Modal.showModal("generalModal");
        sideMenu.classList.remove("open");
      });
    }
    if (menuHelp) {
      menuHelp.addEventListener("click", function (e) {
        e.preventDefault();
        window.Modal.showModal("helpModal");
        sideMenu.classList.remove("open");
      });
    }
    if (menuMapping) {
      menuMapping.addEventListener("click", function (e) {
        e.preventDefault();
        updateMappingModal();
        window.Modal.showModal("mappingModal");
        sideMenu.classList.remove("open");
      });
    }
    if (menuDownload) {
      menuDownload.addEventListener("click", async function (e) {
        e.preventDefault();
        const configBlock = `<!-- CONFIG-START -->
<script>
  window.AppConfig = ${JSON.stringify(window.Config.config, null, 2)};
<\/script>
<!-- CONFIG-END -->`;
        let finalHtml = "<!DOCTYPE html>\n" + document.documentElement.outerHTML;
        finalHtml = finalHtml.replace(/<!--\s*CONFIG-START[\s\S]*?CONFIG-END\s*-->/, configBlock);
        if (window.showSaveFilePicker) {
          try {
            const opts = {
              types: [{
                description: "HTML Files",
                accept: { "text/html": [".html"] }
              }]
            };
            const handle = await window.showSaveFilePicker(opts);
            const writable = await handle.createWritable();
            await writable.write(finalHtml);
            await writable.close();
          } catch (err) {
            console.error("Save cancelled", err);
          }
        } else {
          const blob = new Blob([finalHtml], { type: "text/html" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = "programm.html";
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        }
        sideMenu.classList.remove("open");
      });
    }

    // -----------------------------
    // Mapping Modal Update
    // -----------------------------
    window.updateMappingModal = function () {
      const container = document.getElementById("mappingModalContent");
      const mapping = window.anonymizer.getMapping();
      let html = "<table style='width: 100%; border-collapse: collapse;'>";
      html += "<thead><tr style='border-bottom: 1px solid #ccc;'><th style='text-align:left; padding: 4px;'>Original</th><th style='text-align:left; padding: 4px;'>Token</th><th style='text-align:left; padding: 4px;'>Typ</th></tr></thead>";
      html += "<tbody>";
      mapping.forEach(entry => {
        const original = entry[0];
        const token = entry[1] === null ? "null" : entry[1];
        const type = entry[2].placeholderPrefix;
        html += `<tr style="border-bottom: 1px solid #eee;">
                    <td style="padding: 4px;">${Utils.escapeHtml(original)}</td>
                    <td style="padding: 4px;">${Utils.escapeHtml(token)}</td>
                    <td style="padding: 4px;">${Utils.escapeHtml(type)}</td>
                 </tr>`;
      });
      html += "</tbody></table>";
      container.innerHTML = html;
    };

    // -----------------------------
    // Context Menu: Managed exclusively in contextMenu.js.
    // Initialize the context menu.
    if (window.ContextMenu && typeof window.ContextMenu.init === "function") {
      window.ContextMenu.init("editor", "contextMenu");
    }

    // -----------------------------
    // Highlight and Editor Management
    // -----------------------------
    const editor = document.getElementById("editor");
    const highlight = document.getElementById("highlight");
    function updateHighlight() {
      const text = editor.value;
      if (text.trim() === "") {
        highlight.innerHTML = `<span class="placeholder">${editor.placeholder}</span>`;
        highlight.className = "";
        return;
      }

      let intervals = [];
      // Collect intervals for detected PII and placeholders.
      let detectedIntervals = Utils.collectIntervals(text, window.anonymizer.getMapping().map(entry => entry[0]), "detected");
      detectedIntervals = Utils.mergeOverlappingIntervals(detectedIntervals);
      intervals = intervals.concat(detectedIntervals);
      intervals = intervals.concat(Utils.collectIntervals(text, window.anonymizer.getMapping().map(entry => entry[1]), "anonymized"));

      // Add whitelist intervals.
      const whitelistItems = window.anonymizer.whitelist.filter(item => item.trim() !== "");
      intervals = intervals.concat(Utils.collectIntervals(text, whitelistItems, "whitelisted"));

      intervals.sort((a, b) => a.start - b.start);

      let result = "";
      let currentIndex = 0;
      intervals.forEach(interval => {
        result += Utils.escapeHtml(text.substring(currentIndex, interval.start));
        result += `<span class="${interval.className}">` + Utils.escapeHtml(text.substring(interval.start, interval.end)) + "</span>";
        currentIndex = interval.end;
      });
      result += Utils.escapeHtml(text.substring(currentIndex));
      highlight.innerHTML = result;

      // Set highlight classes.
      if (window.anonymizer.getMapping().some(entry => text.indexOf(entry[0]) !== -1)) {
        highlight.classList.add("highlight-detected");
        highlight.classList.remove("highlight-clean");
      } else {
        highlight.classList.add("highlight-clean");
        highlight.classList.remove("highlight-detected");
      }
      highlight.style.height = editor.scrollHeight + "px";
    }
    editor.addEventListener("input", function () {
      updateHighlight();
    });
    editor.addEventListener("scroll", function () {
      highlight.style.transform = `translate(-${editor.scrollLeft}px, -${editor.scrollTop}px)`;
    });
    updateHighlight();
  });

  window.addEventListener("DOMContentLoaded", function () {
    if (window.Icons && window.Icons.logo) {
      const link = document.createElement("link");
      link.rel = "icon";
      link.type = "image/svg+xml";
      link.href = "data:image/svg+xml," + encodeURIComponent(window.Icons.logo);
      document.head.appendChild(link);
    }
  });
})(window);

</script>
    <script>
"use strict";

(function (window) {
  // Show a modal with the given ID.
  function showModal(modalId) {
    const modal = document.getElementById(modalId);
    if (modal) {
      modal.style.display = "block";
    }
  }

  // Hide a modal with the given ID.
  function hideModal(modalId) {
    const modal = document.getElementById(modalId);
    if (modal) {
      modal.style.display = "none";
    }
  }

  // Opens the custom placeholder modal.
  function openCustomPlaceholderModal(selectedText) {
    const modal = document.getElementById("customPlaceholderModal");
    if (modal) {
      // Zuerst das Modal anzeigen, damit der Fokus korrekt gesetzt werden kann.
      modal.style.display = "block";
      const customPatternInput = modal.querySelector("#customPattern");
      const customLabelInput = modal.querySelector("#customLabel");
      if (customPatternInput) {
        customPatternInput.value = selectedText || "";
      }
      if (customLabelInput && window.anonymizer) {
        customLabelInput.value = window.anonymizer.getUniqueSecretLabel();
        // Mit setTimeout sicherstellen, dass der Fokus gesetzt wird, nachdem das Modal gerendert wurde.
        setTimeout(() => {
          customLabelInput.focus();
          customLabelInput.select();
        }, 0);
      }
    } else {
      console.error("Custom Placeholder Modal not found in DOM.");
    }
  }

  // Sets up event handlers for the custom placeholder modal.
  function setupCustomPlaceholderModal() {
    const modal = document.getElementById("customPlaceholderModal");
    if (!modal) return;
    const saveBtn = document.getElementById("saveCustomPlaceholderBtn");
    const cancelBtn = document.getElementById("cancelCustomPlaceholderBtn");
    if (saveBtn) {
      saveBtn.addEventListener("click", function () {
        const pattern = document.getElementById("customPattern").value.trim();
        const label = document.getElementById("customLabel").value.trim();
        if (pattern && label) {
          window.anonymizer.addCustomPlaceholder(label, pattern, false);
          // Nach dem Hinzufügen automatisch anonymisieren
          window.anonymizer.anonymize_singleText(pattern);
          const editor = document.getElementById("editor");
          if (editor) {
            editor.dispatchEvent(new Event("input"));
          }
          modal.style.display = "none";
        } else {
          alert("Bitte fülle beide Felder aus.");
        }
      });
    }
    if (cancelBtn) {
      cancelBtn.addEventListener("click", function () {
        modal.style.display = "none";
      });
    }
  }

  // Updates the placeholder settings modal content.
  function updatePlaceholderOptions() {
    const container = document.getElementById("placeholderOptionsContent");
    if (!container) return;
    container.innerHTML = "";

    const mapping = window.anonymizer.getMapping();
    const customPlaceholders = [];
    const activePlaceholders = [];
    const inactivePlaceholders = [];

    window.anonymizer.placeholderTypes.forEach(ph => {
      if (ph.isCustom) {
        customPlaceholders.push(ph);
      } else {
        const isActive = mapping.some(entry => entry[2].id === ph.id);
        if (isActive) {
          activePlaceholders.push(ph);
        } else {
          inactivePlaceholders.push(ph);
        }
      }
    });

    function createPlaceholderCheckbox(ph) {
      const div = document.createElement("div");
      div.className = "placeholder-item";
      const checkbox = document.createElement("input");
      checkbox.type = "checkbox";
      checkbox.checked = ph.enabled;
      checkbox.dataset.placeholderId = ph.id;
      checkbox.classList.add("placeholder-checkbox");
      const label = document.createElement("label");
      label.textContent = ph.placeholderPrefix;
      label.classList.add("placeholder-label");
      div.appendChild(checkbox);
      div.appendChild(label);
      return div;
    }

    // Custom Placeholders Section.
    if (customPlaceholders.length > 0) {
      const customSection = document.createElement("div");
      customSection.classList.add("placeholder-section");
      const headerCustom = document.createElement("h4");
      headerCustom.textContent = window.translate("contextMenu.customPlaceholders") || "Benutzerdefinierte Platzhalter";
      customSection.appendChild(headerCustom);
      const list = document.createElement("div");
      list.classList.add("placeholder-list");
      customPlaceholders.forEach(ph => list.appendChild(createPlaceholderCheckbox(ph)));
      customSection.appendChild(list);
      container.appendChild(customSection);
    }

    // Active Placeholders Section.
    const activeSection = document.createElement("div");
    activeSection.classList.add("placeholder-section");
    const headerActive = document.createElement("h4");
    headerActive.textContent = window.translate("contextMenu.activePlaceholders") || "Aktive Platzhalter";
    activeSection.appendChild(headerActive);
    if (activePlaceholders.length > 0) {
      const list = document.createElement("div");
      list.classList.add("placeholder-list");
      activePlaceholders.forEach(ph => list.appendChild(createPlaceholderCheckbox(ph)));
      activeSection.appendChild(list);
    } else {
      const noActiveMsg = document.createElement("p");
      noActiveMsg.textContent = window.translate("contextMenu.noActivePlaceholders") || "Aktuell keine aktiven Platzhalter.";
      noActiveMsg.classList.add("no-active-placeholders");
      activeSection.appendChild(noActiveMsg);
    }
    container.appendChild(activeSection);

    // Inactive Placeholders Section with Toggle.
    if (inactivePlaceholders.length > 0) {
      const inactiveSection = document.createElement("div");
      inactiveSection.classList.add("placeholder-section");
      const headerInactive = document.createElement("h4");
      headerInactive.textContent = window.translate("contextMenu.additionalPlaceholders") || "Weitere Platzhalter";
      
      // Toggle button.
      const toggleButton = document.createElement("button");
      toggleButton.textContent = window.translate("contextMenu.showAdditionalPlaceholders") || "Anzeigen";
      toggleButton.classList.add("toggle-button");
      headerInactive.appendChild(toggleButton);
      inactiveSection.appendChild(headerInactive);
      
      const inactiveContainer = document.createElement("div");
      inactiveContainer.classList.add("placeholder-list", "inactive-list");
      inactiveContainer.style.display = "none"; // collapsed by default
      inactivePlaceholders.forEach(ph => inactiveContainer.appendChild(createPlaceholderCheckbox(ph)));
      inactiveSection.appendChild(inactiveContainer);
      container.appendChild(inactiveSection);
      
      toggleButton.addEventListener("click", () => {
        if (inactiveContainer.style.display === "none") {
          inactiveContainer.style.display = "block";
          toggleButton.textContent = window.translate("contextMenu.hideAdditionalPlaceholders") || "Ausblenden";
        } else {
          inactiveContainer.style.display = "none";
          toggleButton.textContent = window.translate("contextMenu.showAdditionalPlaceholders") || "Anzeigen";
        }
      });
    }
    
    // Update Button.
    const updateButton = document.createElement("button");
    updateButton.textContent = window.translate("contextMenu.updateStatus") || "Status aktualisieren";
    updateButton.classList.add("update-button");
    updateButton.addEventListener("click", function () {
      const checkboxes = container.querySelectorAll("input[type='checkbox']");
      checkboxes.forEach(cb => {
        const phId = cb.dataset.placeholderId;
        const newStatus = cb.checked;
        window.anonymizer.setPlaceholderStatus(phId, newStatus);
      });
      alert(window.translate("contextMenu.statusUpdated") || "Placeholder-Status aktualisiert.");
    });
    container.appendChild(updateButton);
  }

  // Expose modal functions.
  window.Modal = {
    showModal,
    hideModal,
    openCustomPlaceholderModal,
    setupCustomPlaceholderModal,
    updatePlaceholderOptions
  };

  document.addEventListener("DOMContentLoaded", function() {
    setupCustomPlaceholderModal();
  });

  // Expose updatePlaceholderOptions globally if benötigt.
  window.updatePlaceholderOptions = updatePlaceholderOptions;

  
  document.addEventListener("DOMContentLoaded", function() {
    if (!localStorage.getItem("firstRunAcknowledged")) {
      const modal = document.getElementById("firstRunModal");
      const okBtn = document.getElementById("firstRunOk");
      const checkbox = document.getElementById("firstRunCheckbox");
      const languageContainer = document.querySelector("#firstRunModal .language-settings");
  
      // Reuse language selection from the general modal
      const generalLanguageSelect = document.getElementById("languageSelect");
      const generalLanguageLabel = document.querySelector("label[for='languageSelect']");
      if (generalLanguageSelect && generalLanguageLabel && languageContainer) {
        // Clone the label and select elements
        const clonedLabel = generalLanguageLabel.cloneNode(true);
        const clonedSelect = generalLanguageSelect.cloneNode(true);
        // Remove duplicate IDs and 'for' attribute to avoid conflicts
        clonedSelect.removeAttribute("id");
        clonedLabel.removeAttribute("for");
  
        // Clear the container and append the clones
        languageContainer.innerHTML = "";
        languageContainer.appendChild(clonedLabel);
        languageContainer.appendChild(clonedSelect);
  
        // Set the select's value from the current configuration
        if (window.Config && typeof window.Config.get === "function") {
          clonedSelect.value = window.Config.get("language") || "de";
        }
        clonedSelect.addEventListener("change", function(e) {
          window.Config.set("language", e.target.value);
            if (typeof window.updateLanguage === "function") {
              window.updateLanguage();
            }
        });
      }
  
      modal.style.display = "block";
  
      // Enable OK button only when the checkbox is checked
      checkbox.addEventListener("change", function() {
        okBtn.disabled = !checkbox.checked;
      });
  
      okBtn.addEventListener("click", function() {
        localStorage.setItem("firstRunAcknowledged", "true");
        modal.style.display = "none";
      });
    }
  });
  
  
  
})(window);



</script>
    <script>
"use strict";

document.addEventListener("DOMContentLoaded", function () {
  // Configuration for clickable elements for text highlighting.
  const clickableElementsConfig = {
    detected: { className: "detected" },
    placeholder: { className: "anonymized" },
    whitelist: { className: "whitelisted" }
  };

  const editor = document.getElementById("editor");
  const highlight = document.getElementById("highlight");
  const progressBar = document.getElementById("progressBar");
  const progressStatus = document.getElementById("progressStatus"); // Optional status element

  const anonymizeBtn = document.getElementById("anonymizeBtn");
  const deanonymizeBtn = document.getElementById("deanonymizeBtn");

  anonymizeBtn.disabled = true;
  deanonymizeBtn.disabled = true;

  let progressHideTimeout; // Timer for auto-hiding the status message
  let hideBarAnimationTimeout; // Timer for the CSS fadeout

  // Global arrays for detected sensitive data and placeholder tokens.
  let detectedPIIinText = [];
  let placeholderTokensInText = [];

  // Update the debug mapping table, if available.
  function updatePlaceholdersTable() {
    const mappingContainer = document.getElementById("mappingTable");
    if (!mappingContainer) return;
    const mapping = window.anonymizer.getMapping();
    let html = "<table><thead><tr><th>Original</th><th>Token</th><th>Type</th></tr></thead><tbody>";
    mapping.forEach(entry => {
      const original = entry[0];
      const token = entry[1] === null ? "null" : entry[1];
      const type = entry[2].placeholderPrefix;
      html += `<tr>
                <td>${Utils.escapeHtml(original)}</td>
                <td>${Utils.escapeHtml(token)}</td>
                <td>${Utils.escapeHtml(type)}</td>
              </tr>`;
    });
    html += "</tbody></table>";
    mappingContainer.innerHTML = html;
  }

  // Update the current mapping lists based on the editor text.
  function updateCurrentMappingLists() {
    const snapshot = editor.value;
    const mapping = window.anonymizer.getMapping();
    detectedPIIinText = mapping
      .filter(entry => snapshot.includes(entry[0]))
      .map(entry => entry[0]);
    placeholderTokensInText = mapping
      .filter(entry => snapshot.includes(entry[1]))
      .map(entry => entry[1]);
  }

  // Update the UI of the progress bar.
  function updateProgressUI(percent, message) {
    if (window.anonymizer.scanCompleted) return;
    if (progressBar) {
      progressBar.style.display = "block";
      progressBar.classList.add("active");
      progressBar.classList.remove("fade-out");
      const progressFill = document.getElementById("progressFill");
      const progressText = document.getElementById("progressText");
      if (progressFill) progressFill.style.width = percent + "%";
      if (progressText) progressText.innerText = message;
    }
  }

  const throttledProgressUI = Utils.throttle(updateProgressUI, 100);

  // Callback when text scan is complete.
  function handleProgressComplete() {
    const progressFill = document.getElementById("progressFill");
    const progressText = document.getElementById("progressText");
    if (progressFill) {
      progressFill.style.width = "100%";
      progressFill.classList.add("complete");
    }
    if (progressText) {
      progressText.innerHTML =
        'Text scan complete <span style="font-size:24px;">' + Icons.check + '</span>';
    }
    updatePlaceholdersTable();
    updateButtonStates();
    clearTimeout(progressHideTimeout);
    progressHideTimeout = setTimeout(hideProgressBar, 1000);
  }

  // Hide the progress bar.
  function hideProgressBar() {
    if (progressBar) {
      progressBar.classList.add("fade-out");
      hideBarAnimationTimeout = setTimeout(function () {
        progressBar.classList.remove("active", "fade-out");
        progressBar.style.display = "none";
        const progressFill = document.getElementById("progressFill");
        if (progressFill) {
          progressFill.style.width = "0";
          progressFill.classList.remove("complete");
        }
      }, 1000);
    }
  }

  // Show a status message.
  function showStatusMessage(message, clickHandler) {
    if (progressHideTimeout) {
      clearTimeout(progressHideTimeout);
    }
    if (hideBarAnimationTimeout) {
      clearTimeout(hideBarAnimationTimeout);
    }
    
    progressBar.style.display = "block";
    progressBar.classList.add("active");
    progressBar.classList.remove("fade-out");
    const progressFill = document.getElementById("progressFill");
    const progressText = document.getElementById("progressText");
    if (progressFill) {
      progressFill.style.width = "100%";
      progressFill.classList.add("complete");
    }
    if (progressText) {
      progressText.innerHTML = message;
      progressText.onclick = null;
      if (clickHandler && typeof clickHandler === "function") {
        progressText.style.cursor = "pointer";
        progressText.onclick = clickHandler;
      } else {
        progressText.style.cursor = "default";
      }
    }
    
    progressHideTimeout = setTimeout(function() {
      hideProgressBar();
    }, 2000);
  }

  // Update highlight, mapping lists, button states, and the debug table.
  function mappingChangeHandler() {
    updateCurrentMappingLists();
    updateHighlight();
    updateButtonStates();
    updatePlaceholdersTable();
  }

  // Update text based on anonymizer changes.
  function handleTextChange() {
    editor.value = window.anonymizer.getText();
    updateCurrentMappingLists();
    updateHighlight();
    updatePlaceholdersTable();
  }

  const throttledMappingChange = Utils.throttle(mappingChangeHandler, 100);

  // Update the highlight layer based on detected intervals.
  function updateHighlight() {
    const text = editor.value;
    if (text.trim() === "") {
      // Use the translated placeholder so that only the highlight shows it.
      highlight.innerHTML = `<span class="placeholder">${window.translate("editorPlaceholder")}</span>`;
      highlight.className = "";
      return;
    }

    let intervals = [];

    // Collect intervals for detected PII and placeholders.
    let detectedIntervals = Utils.collectIntervals(text, detectedPIIinText, clickableElementsConfig.detected.className);
    detectedIntervals = Utils.mergeOverlappingIntervals(detectedIntervals);
    intervals = intervals.concat(detectedIntervals);
    intervals = intervals.concat(Utils.collectIntervals(text, placeholderTokensInText, clickableElementsConfig.placeholder.className));

    // Add whitelist intervals.
    const whitelistItems = window.anonymizer.whitelist.filter(item => item.trim() !== "");
    intervals = intervals.concat(Utils.collectIntervals(text, whitelistItems, clickableElementsConfig.whitelist.className));

    intervals.sort((a, b) => a.start - b.start);

    let result = "";
    let currentIndex = 0;
    intervals.forEach(interval => {
      result += Utils.escapeHtml(text.substring(currentIndex, interval.start));
      result += `<span class="${interval.className}">` + Utils.escapeHtml(text.substring(interval.start, interval.end)) + "</span>";
      currentIndex = interval.end;
    });
    result += Utils.escapeHtml(text.substring(currentIndex));
    highlight.innerHTML = result;

    // Update highlight classes.
    if (detectedPIIinText.length > 0) {
      highlight.classList.add("highlight-detected");
      highlight.classList.remove("highlight-clean");
    } else {
      highlight.classList.add("highlight-clean");
      highlight.classList.remove("highlight-detected");
    }

    // Adjust highlight height to match the editor.
    highlight.style.height = editor.scrollHeight + "px";
  }

  // Update button states based on current text.
  function updateButtonStates() {
    anonymizeBtn.disabled = detectedPIIinText.length === 0;
    deanonymizeBtn.disabled = placeholderTokensInText.length === 0;
  }

  editor.addEventListener("input", function () {
    clearTimeout(progressHideTimeout);
    clearTimeout(hideBarAnimationTimeout);
    highlight.innerText = editor.value;
    window.anonymizer.setText(editor.value);
    window.anonymizer.identifyPII();
    throttledMappingChange.flush();
  });

  editor.addEventListener("scroll", function () {
    highlight.style.transform = `translate(-${editor.scrollLeft}px, -${editor.scrollTop}px)`;
  });

  // Update highlight and layout on window resize.
  window.addEventListener("resize", function () {
    updateHighlight();
    highlight.style.transform = `translate(-${editor.scrollLeft}px, -${editor.scrollTop}px)`;
  });

  // Anonymize button click handler.
  anonymizeBtn.addEventListener("click", function () {
    window.anonymizer.anonymize();
    anonymizeBtn.disabled = true;
    updateButtonStates();

    showStatusMessage(
      `<span style="font-size:24px; color: green;">${Icons.check}</span> ${window.translate("anonymizedStatus")}`
    );
  });

  // Deanonymize button click handler.
  deanonymizeBtn.addEventListener("click", function () {
    window.anonymizer.deanonymize();
    updateHighlight();
    updateButtonStates();
    showStatusMessage(
      `<span style="font-size:24px; color: green;">${Icons.check}</span> ${window.translate("deanonymizedStatus")}`
    );
  });

  // Register anonymizer callbacks.
  window.anonymizer.setOnMappingChange(throttledMappingChange);
  window.anonymizer.setOnProgress(throttledProgressUI);
  window.anonymizer.setOnComplete(handleProgressComplete);
  window.anonymizer.setOnTextChange(handleTextChange);

  // Overlay copy button handler.
  const copyOverlayBtn = document.getElementById("copyOverlayBtn");
  if (copyOverlayBtn) {
    copyOverlayBtn.addEventListener("click", function () {
      const text = window.anonymizer.getText();
      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(text).then(function () {
          const originalText = copyOverlayBtn.innerHTML;
          copyOverlayBtn.innerHTML = `<span style="font-size:16px;">📋</span> ${window.translate("copySuccess")}`;
          setTimeout(function () {
            copyOverlayBtn.innerHTML = originalText;
          }, 3000);
        });
      } else {
        alert(window.translate("clipboardNotAvailable"));
      }
    });
  }

  // Initial call to update the highlight.
  updateHighlight();
});

</script>
    <script>
"use strict";

(function (window) {
  const ContextMenu = {
    lastSelectionRange: { start: 0, end: 0 },
    lastMenuSelectionRange: null, // Stores the selection range for which the menu was last built

    // Clears the selection by moving the cursor to the end of the last selection range.
    clearSelection(editor) {
      editor.setSelectionRange(this.lastSelectionRange.end, this.lastSelectionRange.end);
    },

    // Retrieves clickable elements (whitelist entries and placeholders) found in the given selection.
    async getClickableElementsInSelection(selection) {
      const whitelistFound = window.anonymizer.whitelist.filter(wl =>
        wl.trim() !== "" && selection.indexOf(wl) !== -1
      );
      const mapping = window.anonymizer.getMapping();
      const placeholderFound = {};
      mapping.forEach(entry => {
        if (entry[0] && selection.indexOf(entry[0]) !== -1) {
          placeholderFound[entry[2].placeholderPrefix] = entry[2];
        }
        if (entry[1] && selection.indexOf(entry[1]) !== -1) {
          placeholderFound[entry[2].placeholderPrefix] = entry[2];
        }
      });
      return { whitelist: [...new Set(whitelistFound)], placeholder: placeholderFound };
    },

    // Retrieves positions of candidate clickable elements in the editor text.
    async getClickableCandidatePositions(editor) {
      const text = editor.value;
      const positions = [];
      const mapping = window.anonymizer.getMapping();
      // Process both original and masked tokens in a single loop.
      mapping.forEach(entry => {
        [entry[0], entry[1]].forEach(candidate => {
          if (candidate) {
            let index = text.indexOf(candidate);
            while (index !== -1) {
              positions.push({ candidate: candidate, start: index, end: index + candidate.length });
              index = text.indexOf(candidate, index + 1);
            }
          }
        });
      });
      window.anonymizer.whitelist.forEach(wl => {
        if (wl.trim() !== "") {
          let index = text.indexOf(wl);
          while (index !== -1) {
            positions.push({ candidate: wl, start: index, end: index + wl.length });
            index = text.indexOf(wl, index + 1);
          }
        }
      });
      return positions;
    },

    // Adjusts the selection to include entire clickable elements.
    async adjustSelectionToClickableElements(editor) {
      const text = editor.value;
      let start = editor.selectionStart;
      let end = editor.selectionEnd;
      const positions = await this.getClickableCandidatePositions(editor);
      positions.forEach(pos => {
        if (text.substring(start, end).indexOf(pos.candidate) !== -1) {
          start = Math.min(start, pos.start);
          end = Math.max(end, pos.end);
        }
      });
      return { start, end };
    },

    // Updates the last selection range to include full clickable elements.
    async updateLastSelectionRange(editor) {
      if (editor.selectionEnd - editor.selectionStart > 0) {
        const adjusted = await this.adjustSelectionToClickableElements(editor);
        editor.setSelectionRange(adjusted.start, adjusted.end);
        this.lastSelectionRange = { start: adjusted.start, end: adjusted.end };
      }
    },

    // Builds the context menu based on the current text selection.
    async buildContextMenuAsync(editor, contextMenu, e) {
      let selStart = editor.selectionStart;
      let selEnd = editor.selectionEnd;
      let selection = editor.value.substring(selStart, selEnd).trim();
      if (!selection) {
        selection = editor.value.substring(this.lastSelectionRange.start, this.lastSelectionRange.end).trim();
      }
      
      // Get whitelist and placeholder info.
      const clickable = await this.getClickableElementsInSelection(selection);
      const whitelistFound = clickable.whitelist;
      const placeholderFound = clickable.placeholder;
      contextMenu.innerHTML = "";

      const mapping = window.anonymizer.getMapping();
      // Unmasked entries indicate PII that can be anonymized.
      const anonymizableEntries = mapping.filter(entry => entry[0] && selection.indexOf(entry[0]) !== -1);
      // Masked tokens indicate deanonymizable entries.
      const deanonymizableEntries = mapping.filter(entry => entry[1] && selection.indexOf(entry[1]) !== -1);

      // "Never anonymize" button.
      if (selection.length > 0) {
        const btnNeverAnonymize = Utils.createButton(
          "⛔ " + window.translate("contextMenu.neverAnonymize"),
          ev => {
            ev.preventDefault();
            editor.focus();
            editor.setSelectionRange(this.lastSelectionRange.start, this.lastSelectionRange.end);
            window.anonymizer.addToWhitelist(selection);
            editor.dispatchEvent(new Event("input"));
            contextMenu.style.display = "none";
            this.clearSelection(editor);
          }
        );
        contextMenu.appendChild(btnNeverAnonymize);
      }

      // Batch anonymization button.
      if (anonymizableEntries.length > 0) {
        const uniqueOriginals = [...new Set(anonymizableEntries.map(entry => entry[0]))];
        const btnBatchAnonymize = Utils.createButton(
          "🛡️ " + window.translate("contextMenu.anonymizeSelection", [uniqueOriginals.length]),
          ev => {
            ev.preventDefault();
            editor.focus();
            editor.setSelectionRange(this.lastSelectionRange.start, this.lastSelectionRange.end);
            uniqueOriginals.forEach(original => {
              window.anonymizer.anonymizeSingleText(original);
            });
            editor.value = window.anonymizer.getText();
            editor.dispatchEvent(new Event("input"));
            contextMenu.style.display = "none";
            this.clearSelection(editor);
          }
        );
        contextMenu.appendChild(btnBatchAnonymize);
      }

      // Batch deanonymization button.
      if (deanonymizableEntries.length > 0) {
        const uniqueTokens = [...new Set(deanonymizableEntries.map(entry => entry[1]))];
        const btnBatchDeanonymize = Utils.createButton(
          "👀 " + window.translate("contextMenu.unmaskSelection") + (uniqueTokens.length > 1 ? " (" + uniqueTokens.length + ")" : ""),
          ev => {
            ev.preventDefault();
            editor.focus();
            editor.setSelectionRange(this.lastSelectionRange.start, this.lastSelectionRange.end);
            uniqueTokens.forEach(token => {
              window.anonymizer.deanonymizeSingleToken(token);
            });
            editor.value = window.anonymizer.getText();
            editor.dispatchEvent(new Event("input"));
            contextMenu.style.display = "none";
            this.clearSelection(editor);
          }
        );
        contextMenu.appendChild(btnBatchDeanonymize);
      }

      // "Add placeholder" button.
      if (deanonymizableEntries.length === 0) {
        const btnAddPlaceholder = Utils.createButton(
          "➕ " + window.translate("contextMenu.addPlaceholder"),
          ev => {
            ev.preventDefault();
            editor.focus();
            editor.setSelectionRange(this.lastSelectionRange.start, this.lastSelectionRange.end);
            const selectedText = editor.value.substring(this.lastSelectionRange.start, this.lastSelectionRange.end).trim();
            window.Modal.openCustomPlaceholderModal(selectedText);
            contextMenu.style.display = "none";
            this.clearSelection(editor);
          }
        );
        contextMenu.appendChild(btnAddPlaceholder);
      }

      // "Remove/Disable placeholder" button for each active placeholder.
      Object.keys(placeholderFound).forEach(prefix => {
        const placeholderType = placeholderFound[prefix];
        if (placeholderType.enabled) {
          const btnRemovePlaceholder = Utils.createButton(
            "❌ " + window.translate("contextMenu.removePlaceholder", [placeholderType.placeholderPrefix]),
            ev => {
              ev.preventDefault();
              editor.focus();
              const tokensToDeanonymize = mapping
                .filter(entry => entry[2].id === placeholderType.id && entry[1] && selection.indexOf(entry[1]) !== -1)
                .map(entry => entry[1]);
              tokensToDeanonymize.forEach(token => {
                window.anonymizer.deanonymizeSingleToken(token);
              });
              window.anonymizer.setPlaceholderStatus(placeholderType.id, false);
              editor.dispatchEvent(new Event("input"));
              contextMenu.style.display = "none";
              this.clearSelection(editor);
            }
          );
          contextMenu.appendChild(btnRemovePlaceholder);
        }
      });

      // Whitelist options.
      if (whitelistFound.length > 0) {
        if (whitelistFound.length > 3) {
          const btn = Utils.createButton(
            window.translate("contextMenu.makeWholeTextAnonymizable"),
            ev => {
              ev.preventDefault();
              editor.focus();
              whitelistFound.forEach(wl => window.anonymizer.removeFromWhitelist(wl));
              editor.dispatchEvent(new Event("input"));
              contextMenu.style.display = "none";
              this.clearSelection(editor);
            }
          );
          contextMenu.appendChild(btn);
        } else {
          whitelistFound.forEach(wl => {
            const displayText = wl.length > 50 ? wl.slice(0, 50) + "..." : wl;
            const btn = Utils.createButton(
              window.translate("contextMenu.makeTextAnonymizable", [displayText]),
              ev => {
                ev.preventDefault();
                editor.focus();
                window.anonymizer.removeFromWhitelist(wl);
                editor.dispatchEvent(new Event("input"));
                contextMenu.style.display = "none";
                this.clearSelection(editor);
              }
            );
            contextMenu.appendChild(btn);
          });
        }
      }
    },

    // Displays the context menu at an appropriate position based on the event.
    async showContextMenu(editor, contextMenu, e) {
      if ((editor.selectionEnd - editor.selectionStart < 1) && (this.lastSelectionRange.end <= this.lastSelectionRange.start)) {
        contextMenu.style.display = "none";
        return;
      }
      // Only rebuild the menu if the selection has changed.
      let currentRange = { start: editor.selectionStart, end: editor.selectionEnd };
      if (this.lastMenuSelectionRange &&
          currentRange.start === this.lastMenuSelectionRange.start &&
          currentRange.end === this.lastMenuSelectionRange.end &&
          contextMenu.style.display === "flex") {
        return;
      }
      this.lastMenuSelectionRange = { start: currentRange.start, end: currentRange.end };
      await this.buildContextMenuAsync(editor, contextMenu, e);
      const menuWidth = contextMenu.offsetWidth;
      const menuHeight = contextMenu.offsetHeight;
      let posX = e.clientX - menuWidth / 2;
      let posY = e.clientY + 10;
      if (posX < 0) posX = 0;
      if (posX + menuWidth > window.innerWidth) posX = window.innerWidth - menuWidth;
      if (posY + menuHeight > window.innerHeight) {
        posY = e.clientY - menuHeight - 10;
        if (posY < 0) posY = 0;
      }
      contextMenu.style.left = posX + "px";
      contextMenu.style.top = posY + "px";
      contextMenu.style.display = "flex";
    },

    // Handles clicks within the editor.
    async handleEditorClick(editor, contextMenu, e) {
      // Check if the click is on a sensitive (highlighted) area.
      const highlight = document.getElementById("highlight");
      const sensitiveElements = highlight.querySelectorAll("span.detected, span.anonymized, span.whitelisted, span.placeholder");
      let clickOnSensitive = false;
      sensitiveElements.forEach(el => {
        const rect = el.getBoundingClientRect();
        if (e.clientX >= rect.left && e.clientX <= rect.right &&
            e.clientY >= rect.top && e.clientY <= rect.bottom) {
          clickOnSensitive = true;
        }
      });
      if (!clickOnSensitive) {
        contextMenu.style.display = "none";
        return;
      }
      if (editor.selectionStart === editor.selectionEnd) {
        // If caret is at end of text, close menu.
        if (editor.selectionStart === editor.value.length) {
          contextMenu.style.display = "none";
          return;
        }
        const caretPos = editor.selectionStart;
        const text = editor.value;
        let foundMatch = null;
        const positions = await this.getClickableCandidatePositions(editor);
        for (let pos of positions) {
          if (caretPos >= pos.start && caretPos <= pos.end) {
            foundMatch = { start: pos.start, end: pos.end };
            break;
          }
        }
        if (foundMatch) {
          editor.selectionStart = foundMatch.start;
          editor.selectionEnd = foundMatch.end;
          this.lastSelectionRange = { start: foundMatch.start, end: foundMatch.end };
          await this.showContextMenu(editor, contextMenu, e);
        }
      }
    },

    // Registers event listeners for the editor and document.
    registerEventListeners(editor, contextMenu) {
      editor.addEventListener("mouseup", async e => {
        await this.updateLastSelectionRange(editor);
        setTimeout(async () => {
          if (editor.selectionEnd - editor.selectionStart >= 1) {
            await this.showContextMenu(editor, contextMenu, e);
          }
        }, 0);
      });

      editor.addEventListener("keyup", async () => {
        await this.updateLastSelectionRange(editor);
        setTimeout(() => {
          if (editor.selectionEnd - editor.selectionStart < 1) {
            contextMenu.style.display = "none";
          }
        }, 0);
      });

      editor.addEventListener("click", async e => {
        await this.handleEditorClick(editor, contextMenu, e);
      });

      // Close menu on every click outside the context menu.
      document.addEventListener("click", e => {
        if (!e.target.closest("#contextMenu")) {
          contextMenu.style.display = "none";
        }
      });
    },

    // Initializes the context menu by registering the event listeners.
    init(editorId, contextMenuId) {
      const editor = document.getElementById(editorId);
      const contextMenu = document.getElementById(contextMenuId);
      if (!editor || !contextMenu) return;
      this.registerEventListeners(editor, contextMenu);
    }
  };

  window.ContextMenu = ContextMenu;
})(window);

</script>

  </head>
  <body>
    <!-- Header section -->
    <header>
      <!-- Hamburger menu (visible on small screens) -->
      <div class="hamburger" id="openMenu" aria-label="Open Menu" title="Open Menu">&#9776;</div>
      
      <!-- Site title and logo -->
      <div class="header-title">
        <div class="header-logo" id="headerLogo" aria-label="Logo"></div>
        <div class="header-text">
          <h1 data-i18n="headerTitle">Anonymat</h1>
          <span data-i18n="headerSubtitle">Persönliche Informationen lokal maskieren</span>
        </div>
      </div>
      
      <!-- Action buttons in the header using emoji icons -->
      <div class="header-actions">
        <!-- Button to add a new placeholder -->
        <button id="headerAddPlaceholder" data-i18n-alt="addPlaceholder">
          <span class="icon">➕</span>
        </button>
        <!-- Button for placeholder settings -->
        <button id="headerSettings" data-i18n-alt="settings">
          <span class="icon">🛠️</span>
        </button>
        <!-- Button to change the language -->
        <button id="headerGeneral" data-i18n-alt="languageChange">
          <span class="icon">🌐</span>
        </button>
        <!-- Button to show help/about information -->
        <button id="headerHelp" data-i18n-alt="help">
          <span class="icon">💡</span>
        </button>
        <!-- Button to view the mapping (anonymization data) -->
        <button id="headerMapping" data-i18n-alt="mapping">
          <span class="icon">📋</span>
        </button>
        <!-- Button to download the program as a separate file -->
        <button id="downloadProgramBtn" data-i18n-alt="programSave">
          <span class="icon">⬇️</span>
        </button>
      </div>
    </header>
    
    <!-- Off-canvas side menu for small screens -->
    <nav id="sideMenu">
      <!-- Close button for side menu -->
      <div class="close-menu" id="closeMenu" aria-label="Close Menu" title="Close Menu">&times;</div>
      <ul>
        <li>
          <a href="#" id="menuAddPlaceholder" title="Add Placeholder" aria-label="Add Placeholder">
            <span class="icon" data-i18n-alt="addPlaceholder">➕</span>
            <span class="menu-text" data-i18n="addPlaceholder">Platzhalter hinzufügen</span>
          </a>
        </li>
        <li>
          <a href="#" id="menuSettings" title="Placeholder Settings" aria-label="Placeholder Settings">
            <span class="icon" data-i18n-alt="settings">🛠️</span>
            <span class="menu-text" data-i18n="settings">Platzhaltereinstellungen</span>
          </a>
        </li>
        <li>
          <a href="#" id="menuGeneral" title="Change Language" aria-label="Change Language">
            <span class="icon" data-i18n-alt="languageChange">🌐</span>
            <span class="menu-text" data-i18n="languageChange">Sprache ändern</span>
          </a>
        </li>
        <li>
          <a href="#" id="menuHelp" title="Help/About" aria-label="Help/About">
            <span class="icon" data-i18n-alt="help">💡</span>
            <span class="menu-text" data-i18n="help">Hilfe/About</span>
          </a>
        </li>
        <li>
          <a href="#" id="menuMapping" title="Show Mapping" aria-label="Show Mapping">
            <span class="icon" data-i18n-alt="mapping">📋</span>
            <span class="menu-text" data-i18n="mapping">Mapping anzeigen</span>
          </a>
        </li>
        <li>
          <a href="#" id="menuDownload" title="Save program as separate file" aria-label="Save program as separate file">
            <span class="icon" data-i18n-alt="programSave">⬇️</span>
            <span class="menu-text" data-i18n="programSave">Programm speichern</span>
          </a>
        </li>
      </ul>
    </nav>
    
    <!-- Main content area -->
    <main>
      <div id="container">
        <div id="scrollable">
          <!-- Highlight layer for displaying colored overlays on detected text -->
          <pre id="highlight"></pre>
          <!-- Transparent textarea for actual text input -->
          <!-- Removed native placeholder attribute so that the placeholder is only shown in the highlight area -->
          <textarea id="editor" spellcheck="false"></textarea>
        </div>
        
        <!-- Button overlay to copy text to clipboard -->
        <button id="copyOverlayBtn" data-i18n="copyToClipboard">In Zwischenablage kopieren</button>
        
        <!-- Progress bar to show scan/anonymization status -->
        <div id="progressBar">
          <div id="progressFill"></div>
          <div id="progressText">Loading...</div>
        </div>
        
        <!-- Action buttons for anonymization and deanonymization -->
        <div id="actionButtons">
          <button class="action-btn" id="anonymizeBtn" aria-label="Anonymize" data-i18n-alt="anonymize">
            <span class="icon">🛡️</span>
            <span class="label" data-i18n="anonymize">Anonymisieren</span>
          </button>
          <button class="action-btn" id="deanonymizeBtn" aria-label="Deanonymize" data-i18n-alt="deanonymize">
            <span class="icon">👀</span>
            <span class="label" data-i18n="deanonymize">Deanonymisieren</span>
          </button>
        </div>
      </div>
    </main>
    
    <!-- Footer (currently empty, reserved for future use) -->
    <footer>
    </footer>
    
    <!-- Modals -->
    
    <body>
      <!-- First Run Modal -->
      <div id="firstRunModal" class="modal">
        <div class="modal-content">
          <h3 data-i18n="firstRunModal.title">
            <span class="warning-emoji">⚠️</span> Wichtiger Hinweis:
          </h3>
          <p data-i18n="firstRunModal.text">
            Dieses Programm übernimmt keine Garantie für die hundertprozentige Erkennung sensibler Informationen in Texten. Die Endverantwortung liegt beim Benutzer. Dieses Tool dient ausschließlich als semiautomatische Unterstützung zur Anonymisierung von Texten.
          </p>
          <div class="first-run-checkbox">
            <input type="checkbox" id="firstRunCheckbox">
            <label for="firstRunCheckbox" data-i18n="firstRunModal.checkbox">Ich habe das gelesen und verstanden</label>
          </div>
          <div class="first-run-button">
            <button id="firstRunOk" disabled data-i18n="firstRunModal.okButton">OK</button>
          </div>
          <div class="language-settings">
            <!-- Sprachauswahl wird dynamisch aus dem vorhandenen generalModal übernommen -->
          </div>
        </div>
      </div>
      
      
      
    
      <!-- Existing content -->
      <!-- Header, nav, main etc. -->
    </body>
    

    <!-- Settings Modal: Allows configuration of placeholder settings -->
    <div id="settingsModal" class="modal">
      <div class="modal-content">
        <h3 data-i18n="placeholderOptions">Platzhaltereinstellungen</h3>
        <div id="placeholderOptionsContent"></div>
        <div style="text-align: center;">
          <button id="closeSettingsModalBtn" data-i18n="close">Schließen</button>
        </div>
      </div>
    </div>
    
    <!-- General Modal: For changing the interface language -->
    <div id="generalModal" class="modal">
      <div class="modal-content">
        <h3 data-i18n="languageChange">Sprache ändern</h3>
        <label for="languageSelect" data-i18n="languageChange">Sprache der Benutzerschnittstelle:</label>
        <select id="languageSelect" style="padding: 8px; font-size: 16px; border: 1px solid #ccc; border-radius: 4px;">
          <option value="de">🇩🇪 Deutsch</option>
          <option value="en">🇬🇧 English</option>
        </select>
        <div style="text-align: center; margin-top: 20px;">
          <button id="closeGeneralModalBtn" data-i18n="close">Schließen</button>
        </div>
      </div>
    </div>
    
    <!-- Help/About Modal: Provides information about the tool -->
    <div id="helpModal" class="modal">
      <div class="modal-content">
        <h3 data-i18n="helpTitle">Über Anonymizer</h3>
        <p data-i18n="helpDescription">
          Anonymizer is a tool for semi-automatic masking and anonymization of personal data in texts.
        </p>
        <p data-i18n="helpLocal">
          This application runs entirely locally in your browser and does not communicate with external services.
        </p>
        <p data-i18n="helpDsGvo">
          The tool is designed to support GDPR-compliant workflows. (The GDPR — General Data Protection Regulation — is a European regulation for data privacy and security.)
        </p>
        <p data-i18n="helpResponsibility">
          Important: Anonymizer offers partial automation. The final responsibility and verification always remain with the user.
        </p>
        <p data-i18n="helpLicense">
          This project is open source and licensed under the MIT license.
        </p>
        <p data-i18n-html="helpVersion"></p>
        <div style="text-align: center; margin-top: 20px;">
          <button id="closeHelpModalBtn" data-i18n="close">Schließen</button>
        </div>
      </div>
    </div>
    
    
    <!-- Mapping Modal: Displays the mapping between original data and placeholders -->
    <div id="mappingModal" class="modal">
      <div class="modal-content">
        <h3 data-i18n="mapping">Mapping-Liste</h3>
        <div id="mappingModalContent">
          <!-- Mapping table will be dynamically inserted here -->
        </div>
        <div style="text-align: center; margin-top: 20px;">
          <button id="resetMappingBtn">Mapping zurücksetzen</button>
          <button id="closeMappingModalBtn" data-i18n="close">Schließen</button>
        </div>
      </div>
    </div>
    
    <!-- Custom Placeholder Modal: For adding user-defined placeholders -->
    <div id="customPlaceholderModal" class="modal" style="display:none;">
      <div class="modal-content">
        <h3>Platzhalter hinzufügen</h3>
        <label for="customPattern">Muster:</label>
        <input type="text" id="customPattern" data-i18n-placeholder="customPatternPlaceholder" placeholder="Enter text to be replaced" />
        <label for="customLabel">Bezeichnung:</label>
        <input type="text" id="customLabel" placeholder="e.g. Secret" />
        <div class="modal-buttons">
          <button id="saveCustomPlaceholderBtn">Speichern</button>
          <button id="cancelCustomPlaceholderBtn">Abbrechen</button>
        </div>
      </div>
    </div>
    
    <!-- Context Menu: Provides quick actions based on text selection -->
    <div id="contextMenu" class="context-menu">
      <button id="ctxAddPlaceholder"><span class="icon">📝</span> Platzhalter hinzufügen</button>
      <button id="ctxDoNotAnonymize"><span class="icon">⛔</span> Diesen Text nicht anonymisieren</button>
    </div>
    
    <!-- Note: Download functionality is implemented in ui.js -->
  </body>
</html>
